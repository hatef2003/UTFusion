--------------------------------------------------------------------------------
Profile data file 'callgrind.out.129788' (creator: callgrind-3.25.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 41854386
Trigger: Program termination
Profiled target:  ./UTFusion (PID 129788, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                   
--------------------------------------------------------------------------------
213,985,439 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                   file:function
--------------------------------------------------------------------------------
20,473,936 ( 9.57%)  ???:0x00000000000099c0 [/usr/lib/ld-linux-x86-64.so.2]
13,793,349 ( 6.45%)  /usr/include/c++/15.1.1/bits/stl_algobase.h:void std::__fill_a1<bool*, bool>(bool*, bool*, bool const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
11,337,280 ( 5.30%)  ???:0x000000000041d7a0 [/usr/lib/libQt6Core.so.6.9.0]
10,219,717 ( 4.78%)  ???:0x00000000001f9f60'2 [/usr/lib/libQt6Core.so.6.9.0]
10,010,762 ( 4.68%)  ???:0x0000000000246830 [/usr/lib/libQt6Core.so.6.9.0]
 8,546,124 ( 3.99%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/string-to-double.cc:double double_conversion::StringToDoubleConverter::StringToIeee<char const*>(char const*, int, bool, int*) const [/usr/lib/libdouble-conversion.so.3.3.0]
 7,569,592 ( 3.54%)  ???:0x00000000000a4c60 [/usr/lib/libc.so.6]
 6,452,089 ( 3.02%)  ???:0x00000000001f9070 [/usr/lib/libQt6Core.so.6.9.0]
 6,380,095 ( 2.98%)  ???:0x00000000001eb940 [/usr/lib/libQt6Core.so.6.9.0]
 6,084,568 ( 2.84%)  ???:free [/usr/lib/libc.so.6]
 4,788,355 ( 2.24%)  ???:0x000000000000a560 [/usr/lib/ld-linux-x86-64.so.2]
 4,557,277 ( 2.13%)  ???:0x00000000001de190 [/usr/lib/libQt6Core.so.6.9.0]
 4,520,713 ( 2.11%)  ???:malloc [/usr/lib/libc.so.6]
 3,658,412 ( 1.71%)  ???:0x000000000044b0e0 [/usr/lib/libQt6Core.so.6.9.0]
 3,624,830 ( 1.69%)  ???:0x000000000000e160 [/usr/lib/ld-linux-x86-64.so.2]
 3,538,584 ( 1.65%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/strtod.cc:double_conversion::ComputeGuess(double_conversion::Vector<char const>, int, double*) [clone .isra.0] [/usr/lib/libdouble-conversion.so.3.3.0]
 3,486,342 ( 1.63%)  /usr/include/qt6/QtCore/qbytearrayview.h:long long QtPrivate::lengthHelperPointer<char>(char const*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
 3,083,846 ( 1.44%)  ???:0x00000000001db6f0 [/usr/lib/libQt6Core.so.6.9.0]
 3,060,957 ( 1.43%)  ???:0x00000000001f6b60 [/usr/lib/libQt6Core.so.6.9.0]
 2,808,904 ( 1.31%)  ???:0x00000000000a3ec0 [/usr/lib/libc.so.6]
 2,743,875 ( 1.28%)  ???:0x00000000000a5db0 [/usr/lib/libc.so.6]
 2,606,544 ( 1.22%)  ???:0x00000000001f7860 [/usr/lib/libQt6Core.so.6.9.0]
 2,404,785 ( 1.12%)  ???:0x0000000000223830 [/usr/lib/libQt6Core.so.6.9.0]
 2,135,432 ( 1.00%)  ???:realloc [/usr/lib/libc.so.6]
 2,111,313 ( 0.99%)  ???:QUtf8::convertToUnicode(char16_t*, QByteArrayView) [/usr/lib/libQt6Core.so.6.9.0]
 1,949,501 ( 0.91%)  ???:0x0000000000025ee0 [/usr/lib/ld-linux-x86-64.so.2]
 1,867,680 ( 0.87%)  ???:0x00000000001fb090'2 [/usr/lib/libQt6Core.so.6.9.0]
 1,773,895 ( 0.83%)  ../../FusionUtils/pixel2world.cpp:PixelToWorld::pixelToWorld(float const*, float, PixelToWorld::CameraIntrinsics const&, PixelToWorld::CameraPose const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
 1,768,680 ( 0.83%)  ???:QJsonObject::operator[](QString const&) [/usr/lib/libQt6Core.so.6.9.0]
 1,734,603 ( 0.81%)  ???:0x0000000000413d40 [/usr/lib/libQt6Core.so.6.9.0]
 1,696,510 ( 0.79%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/string-to-double.cc:bool double_conversion::Advance<char*>(char**, unsigned short, int, char*&) [/usr/lib/libdouble-conversion.so.3.3.0]
 1,609,383 ( 0.75%)  ../../erfanmocker.cpp:ErfanMocker::onReadyRead() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
 1,535,440 ( 0.72%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/strtod.cc:double_conversion::AssertTrimmedDigits(double_conversion::Vector<char const> const&) [clone .isra.0] [/usr/lib/libdouble-conversion.so.3.3.0]
 1,493,704 ( 0.70%)  ???:0x0000000000423f60 [/usr/lib/libQt6Core.so.6.9.0]
 1,454,692 ( 0.68%)  ???:QArrayData::allocate2(QArrayData**, long long, QArrayData::AllocationOption) [/usr/lib/libQt6Core.so.6.9.0]
 1,415,016 ( 0.66%)  ???:QString::fromUtf8(QByteArrayView) [/usr/lib/libQt6Core.so.6.9.0]
 1,379,157 ( 0.64%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/strtod.cc:double_conversion::StrtodTrimmed(double_conversion::Vector<char const>, int) [/usr/lib/libdouble-conversion.so.3.3.0]
 1,335,516 ( 0.62%)  ???:QByteArray::reallocData(long long, QArrayData::AllocationOption) [/usr/lib/libQt6Core.so.6.9.0]
 1,319,599 ( 0.62%)  ???:0x000000000016b820 [/usr/lib/libc.so.6]
 1,262,919 ( 0.59%)  ???:QByteArray::resize(long long) [/usr/lib/libQt6Core.so.6.9.0]
 1,188,768 ( 0.56%)  ???:0x00000000001d6560'2 [/usr/lib/libQt6Core.so.6.9.0]
 1,146,116 ( 0.54%)  ???:0x000000000016bf80 [/usr/lib/libc.so.6]
 1,120,961 ( 0.52%)  ???:0x00000000000a2720 [/usr/lib/libc.so.6]
 1,111,861 ( 0.52%)  ???:0x00000000000a28d0 [/usr/lib/libc.so.6]
 1,111,168 ( 0.52%)  ???:0x0000000000009840 [/usr/lib/ld-linux-x86-64.so.2]
 1,021,908 ( 0.48%)  /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
 1,002,960 ( 0.47%)  ???:0x00000000001f6bf0 [/usr/lib/libQt6Core.so.6.9.0]
   972,583 ( 0.45%)  ???:0x00000000000a2650 [/usr/lib/libc.so.6]
   955,510 ( 0.45%)  ???:0x000000000041de80 [/usr/lib/libQt6Core.so.6.9.0]
   943,296 ( 0.44%)  /usr/include/qt6/QtCore/qbytearrayview.h:QByteArrayView::QByteArrayView<char const*, true>(char const* const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   903,996 ( 0.42%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<char16_t>::~QArrayDataPointer() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   888,510 ( 0.42%)  ???:QJsonValueConstRef::concrete(QJsonValueConstRef) [/usr/lib/libQt6Core.so.6.9.0]
   849,322 ( 0.40%)  ???:0x00000000001f6b00 [/usr/lib/libQt6Core.so.6.9.0]
   825,384 ( 0.39%)  /usr/include/qt6/QtCore/qbytearrayview.h:QByteArrayView::QByteArrayView<char, true>(char const*, long long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   801,996 ( 0.37%)  ???:0x000000000041df90 [/usr/lib/libQt6Core.so.6.9.0]
   762,518 ( 0.36%)  /usr/include/c++/15.1.1/bits/atomic_base.h:int QAtomicOps<int>::loadRelaxed<int>(std::atomic<int> const&)
   718,541 ( 0.34%)  ???:QArrayData::reallocateUnaligned(QArrayData*, void*, long long, long long, QArrayData::AllocationOption) [/usr/lib/libQt6Core.so.6.9.0]
   682,448 ( 0.32%)  ???:0x00000000004140c0 [/usr/lib/libQt6Core.so.6.9.0]
   668,168 ( 0.31%)  /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QPodArrayOps<char16_t>::destroyAll() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   668,168 ( 0.31%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<char16_t>::deref() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   636,232 ( 0.30%)  ../../FusionUtils/fusion.cpp:Fusion::performFusion(std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > > const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   565,828 ( 0.26%)  /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueConstRef::toDouble(double) const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   565,296 ( 0.26%)  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) [/usr/lib/libstdc++.so.6.0.34]
   564,294 ( 0.26%)  ???:QArrayData::allocate1(QArrayData**, long long, QArrayData::AllocationOption) [/usr/lib/libQt6Core.so.6.9.0]
   531,579 ( 0.25%)  ???:QJsonValueConstRef::concreteDouble(QJsonValueConstRef, double) [/usr/lib/libQt6Core.so.6.9.0]
   436,755 ( 0.20%)  /usr/include/qt6/QtCore/qatomic_cxx11.h:bool QAtomicOps<int>::deref<int>(std::atomic<int>&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   426,004 ( 0.20%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/strtod.h:double double_conversion::StringToDoubleConverter::StringToIeee<char const*>(char const*, int, bool, int*) const
   424,368 ( 0.20%)  /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::toDouble(double) const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   403,686 ( 0.19%)  /usr/include/qt6/QtCore/qatomic_cxx11.h:int QAtomicOps<int>::loadRelaxed<int>(std::atomic<int> const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   403,686 ( 0.19%)  /usr/include/qt6/QtCore/qbasicatomic.h:QBasicAtomicInteger<int>::loadRelaxed() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   393,040 ( 0.18%)  /usr/include/qt6/QtCore/qstring.h:QString::~QString() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   373,990 ( 0.17%)  /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::comparesEqual_helper(QJsonArray::iterator const&, QJsonArray::iterator const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   368,288 ( 0.17%)  /usr/include/c++/15.1.1/bits/atomic_base.h:std::operator&(std::memory_order, std::__memory_order_modifier) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   365,428 ( 0.17%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::push_back(Fusion::PixelData const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   357,345 ( 0.17%)  /usr/include/qt6/QtCore/qarraydata.h:QArrayData::deref() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   357,345 ( 0.17%)  /usr/include/qt6/QtCore/qbasicatomic.h:QBasicAtomicInteger<int>::deref() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   340,272 ( 0.16%)  ???:0x0000000000222ea0 [/usr/lib/libQt6Core.so.6.9.0]
   317,547 ( 0.15%)  ../../FusionUtils/pixel2world.cpp:PixelToWorld::pixelToWorld(float*, float) const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   298,804 ( 0.14%)  /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::operator QJsonValue() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   283,860 ( 0.13%)  ???:QJsonValueRef::toValue() const [/usr/lib/libQt6Core.so.6.9.0]
   279,558 ( 0.13%)  ???:0x00000000001e65e0 [/usr/lib/libQt6Core.so.6.9.0]
   268,920 ( 0.13%)  /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator++() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   248,777 ( 0.12%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/utils.h:double double_conversion::StringToDoubleConverter::StringToIeee<char const*>(char const*, int, bool, int*) const
   246,837 ( 0.12%)  ../../FusionUtils/pixel2world.cpp:PixelToWorld::isValidDepth(float, float, float) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   235,824 ( 0.11%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<char16_t>::operator->() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   235,824 ( 0.11%)  /usr/include/qt6/QtCore/qbytearrayview.h:QByteArrayView::castHelper(char const*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   229,478 ( 0.11%)  ???:0x00000000001d9910 [/usr/lib/libQt6Core.so.6.9.0]
   219,830 ( 0.10%)  /usr/include/qt6/QtCore/qjsonarray.h:operator!=(QJsonArray::iterator const&, QJsonArray::iterator const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   218,190 ( 0.10%)  /usr/include/c++/15.1.1/bits/stl_iterator.h:Fusion::performFusion(std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > > const&)
   214,676 ( 0.10%)  ???:0x00000000001d6650'2 [/usr/lib/libQt6Core.so.6.9.0]
   214,570 ( 0.10%)  ???:0x00000000001d9720 [/usr/lib/libQt6Core.so.6.9.0]
   209,007 ( 0.10%)  ???:0x000000000000b750 [/usr/lib/ld-linux-x86-64.so.2]
   205,487 ( 0.10%)  ???:0x00000000000d0700 [/usr/lib/libQt6Core.so.6.9.0]
   204,065 ( 0.10%)  ???:0x00000000001d6560 [/usr/lib/libQt6Core.so.6.9.0]
   202,920 ( 0.09%)  /usr/include/qt6/QtCore/qjsonarray.h:comparesEqual(QJsonArray::iterator const&, QJsonArray::iterator const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   198,525 ( 0.09%)  /usr/include/c++/15.1.1/bits/atomic_base.h:bool QAtomicOps<int>::deref<int>(std::atomic<int>&)
   191,068 ( 0.09%)  ???:QJsonValue::~QJsonValue() [/usr/lib/libQt6Core.so.6.9.0]
   190,368 ( 0.09%)  ???:0x0000000000013880 [/usr/lib/ld-linux-x86-64.so.2]
   176,175 ( 0.08%)  /usr/include/c++/15.1.1/cmath:std::isfinite(float) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   170,622 ( 0.08%)  ???:0x0000000000008900 [/usr/lib/ld-linux-x86-64.so.2]
   165,032 ( 0.08%)  /usr/include/c++/15.1.1/bits/new_allocator.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::push_back(Fusion::PixelData const&)
   160,368 ( 0.07%)  ???:QJsonValue::toObject() const [/usr/lib/libQt6Core.so.6.9.0]
   155,310 ( 0.07%)  ???:0x00000000001e56f0 [/usr/lib/libQt6Core.so.6.9.0]
   141,456 ( 0.07%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/string-to-double.cc:double_conversion::StringToDoubleConverter::StringToDouble(char const*, int, int*) const [/usr/lib/libdouble-conversion.so.3.3.0]
   140,402 ( 0.07%)  ???:0x00000000001d6650 [/usr/lib/libQt6Core.so.6.9.0]
   137,900 ( 0.06%)  ???:0x00000000001e3470 [/usr/lib/libQt6Core.so.6.9.0]
   135,113 ( 0.06%)  ???:0x000000000005f430 [/usr/lib/libglib-2.0.so.0.8400.2]
   129,232 ( 0.06%)  /usr/include/c++/15.1.1/bits/vector.tcc:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::reserve(unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   119,520 ( 0.06%)  /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator*() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   118,200 ( 0.06%)  ???:QJsonArray::detach(long long) [/usr/lib/libQt6Core.so.6.9.0]
   116,564 ( 0.05%)  /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
   116,033 ( 0.05%)  ???:QJsonValueRef::toArray() const [/usr/lib/libQt6Core.so.6.9.0]
   113,137 ( 0.05%)  ???:0x000000000005eb40 [/usr/lib/libglib-2.0.so.0.8400.2]
   102,440 ( 0.05%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::vector(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    99,758 ( 0.05%)  ???:0x0000000000007220 [/usr/lib/ld-linux-x86-64.so.2]
    94,927 ( 0.04%)  ???:QJsonObject::~QJsonObject() [/usr/lib/libQt6Core.so.6.9.0]
    94,560 ( 0.04%)  /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueConstRef::QJsonValueConstRef(QJsonArray*, long long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    94,400 ( 0.04%)  ???:0x0000000000408fd0 [/usr/lib/libQt6Core.so.6.9.0]
    93,181 ( 0.04%)  /usr/include/qt6/QtCore/qarraydataops.h:void QtPrivate::QPodArrayOps<unsigned int>::emplace<unsigned int&>(long long, unsigned int&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    87,468 ( 0.04%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::needsDetach() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    85,104 ( 0.04%)  /usr/include/c++/15.1.1/bits/new_allocator.h:std::__new_allocator<Fusion::PixelData>::allocate(unsigned long, void const*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    84,227 ( 0.04%)  ???:0x000000000005ccb0 [/usr/lib/libglib-2.0.so.0.8400.2]
    82,548 ( 0.04%)  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_opnt.cc:operator new(unsigned long, std::nothrow_t const&) [/usr/lib/libstdc++.so.6.0.34]
    82,516 ( 0.04%)  /usr/include/c++/15.1.1/bits/move.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::push_back(Fusion::PixelData const&)
    78,800 ( 0.04%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::~_Vector_base() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    74,663 ( 0.03%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtEnd() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    70,920 ( 0.03%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_deallocate(Fusion::PixelData*, unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    70,723 ( 0.03%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtBegin() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    70,609 ( 0.03%)  ???:0x00000000000c1490 [/usr/lib/libglib-2.0.so.0.8400.2]
    70,098 ( 0.03%)  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/del_op.cc:operator delete(void*) [/usr/lib/libstdc++.so.6.0.34]
    70,098 ( 0.03%)  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/del_ops.cc:operator delete(void*, unsigned long) [/usr/lib/libstdc++.so.6.0.34]
    69,344 ( 0.03%)  /usr/include/qt6/QtCore/qlist.h:unsigned int& QList<unsigned int>::emplaceBack<unsigned int&>(unsigned int&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    67,965 ( 0.03%)  /usr/include/qt6/QtCore/qarraydata.h:QTypedArrayData<unsigned int>::dataStart(QArrayData*, long long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    66,980 ( 0.03%)  ???:0x00000000001f9f60 [/usr/lib/libQt6Core.so.6.9.0]
    64,937 ( 0.03%)  ???:QByteArray::toLongLong(bool*, int) const [/usr/lib/libQt6Core.so.6.9.0]
    63,044 ( 0.03%)  /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::PixelData* std::uninitialized_copy<__gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, Fusion::PixelData*>(__gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, __gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, Fusion::PixelData*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    63,040 ( 0.03%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::~vector() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    62,496 ( 0.03%)  ???:0x00000000000c2000 [/usr/lib/libglib-2.0.so.0.8400.2]
    59,892 ( 0.03%)  /usr/include/c++/15.1.1/bits/new_allocator.h:std::__new_allocator<Fusion::PixelData>::deallocate(Fusion::PixelData*, unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    59,888 ( 0.03%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::push_back(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    59,100 ( 0.03%)  /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::iterator(QJsonArray*, long long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    59,100 ( 0.03%)  /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::QJsonValueRef(QJsonArray*, long long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    58,372 ( 0.03%)  ???:0x000000000016e550 [/usr/lib/libc.so.6]
    57,130 ( 0.03%)  /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::end() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    56,562 ( 0.03%)  /usr/include/qt6/QtCore/qarraydata.h:QArrayData::needsDetach() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    52,038 ( 0.02%)  ???:QMetaObject::activate(QObject*, QMetaObject const*, int, void**) [/usr/lib/libQt6Core.so.6.9.0]
    51,811 ( 0.02%)  ???:QJsonArray::~QJsonArray() [/usr/lib/libQt6Core.so.6.9.0]
    51,130 ( 0.02%)  ???:0x00000000000a1ce0 [/usr/lib/libc.so.6]
    50,736 ( 0.02%)  ???:0x000000000005c8a0 [/usr/lib/libglib-2.0.so.0.8400.2]
    50,432 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::end() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    50,432 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::size() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    49,254 ( 0.02%)  /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::begin() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    48,384 ( 0.02%)  ???:0x000000000008f8f0 [/usr/lib/libglib-2.0.so.0.8400.2]
    48,265 ( 0.02%)  ???:QIODevicePrivate::read(char*, long long, bool) [/usr/lib/libQt6Core.so.6.9.0]
    47,764 ( 0.02%)  ???:g_value_register_transform_func [/usr/lib/libgobject-2.0.so.0.8400.2]
    47,280 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::begin() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    47,279 ( 0.02%)  ???:pthread_getspecific [/usr/lib/libc.so.6]
    46,552 ( 0.02%)  ???:clock_gettime [/usr/lib/libc.so.6]
    45,704 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_create_storage(unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    44,916 ( 0.02%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::operator->() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    44,916 ( 0.02%)  ???:QJsonValue::toArray() const [/usr/lib/libQt6Core.so.6.9.0]
    42,552 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_S_max_size(std::allocator<Fusion::PixelData> const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    40,976 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_uninitialized.h:std::enable_if<std::__is_bitwise_relocatable<Fusion::PixelData, void>::value, Fusion::PixelData*>::type std::__relocate_a_1<Fusion::PixelData, Fusion::PixelData>(Fusion::PixelData*, Fusion::PixelData*, Fusion::PixelData*, std::allocator<Fusion::PixelData>&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    40,976 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_allocate(unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    40,976 ( 0.02%)  /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::end() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    39,930 ( 0.02%)  ???:g_source_get_name [/usr/lib/libglib-2.0.so.0.8400.2]
    39,203 ( 0.02%)  ???:QIODevice::readyRead() [/usr/lib/libQt6Core.so.6.9.0]
    37,824 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_get_Tp_allocator() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    37,824 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_impl_data::_Vector_impl_data() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    37,824 ( 0.02%)  /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::iterator::operator-(long long) const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    35,854 ( 0.02%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::detach(QArrayDataPointer<unsigned int>*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    35,854 ( 0.02%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::end() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    35,363 ( 0.02%)  /usr/src/debug/double-conversion/double-conversion/double-conversion/utils.h:double_conversion::AssertTrimmedDigits(double_conversion::Vector<char const> const&) [clone .isra.0]
    33,909 ( 0.02%)  ???:0x0000000000014260 [/usr/lib/ld-linux-x86-64.so.2]
    33,096 ( 0.02%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_base(unsigned long, std::allocator<Fusion::PixelData> const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    32,932 ( 0.02%)  ???:0x000000000016c980 [/usr/lib/libc.so.6]
    31,923 ( 0.01%)  ???:0x000000000044a840 [/usr/lib/libQt6Core.so.6.9.0]
    31,566 ( 0.01%)  ???:getenv [/usr/lib/libc.so.6]
    31,520 ( 0.01%)  /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::iterator::iterator(unsigned int*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    31,071 ( 0.01%)  ???:0x000000000005fa00 [/usr/lib/libglib-2.0.so.0.8400.2]
    30,338 ( 0.01%)  /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::detach() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    29,944 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_impl::_Vector_impl(std::allocator<Fusion::PixelData> const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    29,411 ( 0.01%)  ???:0x000000000005e6f0 [/usr/lib/libglib-2.0.so.0.8400.2]
    29,234 ( 0.01%)  ???:QRingBuffer::reserve(long long) [/usr/lib/libQt6Core.so.6.9.0]
    29,110 ( 0.01%)  ???:0x0000000000003790 [/usr/lib/ld-linux-x86-64.so.2]
    28,959 ( 0.01%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::data() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    28,368 ( 0.01%)  /usr/include/c++/15.1.1/bits/new_allocator.h:std::__new_allocator<Fusion::PixelData>::~__new_allocator() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    28,368 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_impl::~_Vector_impl() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    28,171 ( 0.01%)  ../../FusionUtils/fusion.cpp:Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}::operator()(Fusion::RadarData const&, Fusion::RadarData const&) const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    27,268 ( 0.01%)  ???:0x0000000000413350 [/usr/lib/libQt6Core.so.6.9.0]
    27,104 ( 0.01%)  ???:0x0000000000053d00 [/usr/lib/libglib-2.0.so.0.8400.2]
    26,775 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    26,201 ( 0.01%)  ???:QJsonArray::size() const [/usr/lib/libQt6Core.so.6.9.0]
    26,136 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    26,004 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Construct<Fusion::FusionOutput>(Fusion::FusionOutput*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    25,662 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    25,216 ( 0.01%)  /usr/include/c++/15.1.1/bits/alloc_traits.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_allocate(unsigned long)
    25,216 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__unguarded_linear_insert<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Val_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Val_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    25,216 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::capacity() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    24,822 ( 0.01%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::reallocateAndGrow(QArrayData::GrowthPosition, long long, QArrayDataPointer<unsigned int>*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    24,822 ( 0.01%)  /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::operator[](long long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    23,884 ( 0.01%)  /usr/include/qt6/QtCore/qarraydata.h:QArrayData::constAllocatedCapacity() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    23,640 ( 0.01%)  /usr/include/c++/15.1.1/bits/new_allocator.h:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::push_back(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > const&)
    23,640 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_iterator.h:Fusion::PixelData* std::uninitialized_copy<__gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, Fusion::PixelData*>(__gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, __gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, Fusion::PixelData*)
    23,640 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::PixelData* std::__uninitialized_copy_a<__gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, __gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, Fusion::PixelData*, Fusion::PixelData>(__gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, __gnu_cxx::__normal_iterator<Fusion::PixelData const*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >, Fusion::PixelData*, std::allocator<Fusion::PixelData>&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    23,640 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_S_relocate(Fusion::PixelData*, Fusion::PixelData*, Fusion::PixelData*, std::allocator<Fusion::PixelData>&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    22,832 ( 0.01%)  ???:g_str_hash [/usr/lib/libglib-2.0.so.0.8400.2]
    22,458 ( 0.01%)  ../../FusionUtils/fusion.h:Fusion::FusionOutput::FusionOutput() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    22,458 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_M_copy_data(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    22,344 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::~_Vector_base() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    22,120 ( 0.01%)  ???:0x0000000000023830 [/usr/lib/ld-linux-x86-64.so.2]
    22,064 ( 0.01%)  /usr/include/c++/15.1.1/bits/alloc_traits.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_deallocate(Fusion::PixelData*, unsigned long)
    22,064 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Destroy<Fusion::PixelData*>(Fusion::PixelData*, Fusion::PixelData*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    22,064 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::PixelData* std::__relocate_a<Fusion::PixelData*, Fusion::PixelData*, std::allocator<Fusion::PixelData> >(Fusion::PixelData*, Fusion::PixelData*, Fusion::PixelData*, std::allocator<Fusion::PixelData>&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    22,064 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_impl::_Vector_impl() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    21,792 ( 0.01%)  ???:g_source_ref [/usr/lib/libglib-2.0.so.0.8400.2]
    21,670 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_iterator.h:void std::__insertion_sort<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>)
    21,493 ( 0.01%)  ???:QObjectPrivate::maybeSignalConnected(unsigned int) const [/usr/lib/libQt6Core.so.6.9.0]
    21,473 ( 0.01%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::allocateGrow(QArrayDataPointer<unsigned int> const&, long long, QArrayData::GrowthPosition) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    21,276 ( 0.01%)  ???:0x00000000001fb090 [/usr/lib/libQt6Core.so.6.9.0]
    20,882 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__insertion_sort<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    20,750 ( 0.01%)  ???:0x0000000000034d90 [/usr/lib/libgobject-2.0.so.0.8400.2]
    20,488 ( 0.01%)  /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::append(unsigned int) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    20,280 ( 0.01%)  ???:0x0000000000005b80 [/usr/lib/ld-linux-x86-64.so.2]
    18,912 ( 0.01%)  /usr/include/c++/15.1.1/bits/alloc_traits.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::~vector()
    18,912 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_get_Tp_allocator() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    18,722 ( 0.01%)  ???:QIODevice::readAll() [/usr/lib/libQt6Core.so.6.9.0]
    18,620 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::~vector() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    18,321 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__move_merge_adaptive<Fusion::RadarData*, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(Fusion::RadarData*, Fusion::RadarData*, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    17,927 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::FusionOutput* std::__uninitialized_default_n_1<false>::__uninit_default_n<Fusion::FusionOutput*, unsigned long>(Fusion::FusionOutput*, unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    17,777 ( 0.01%)  ???:calloc [/usr/lib/libc.so.6]
    17,614 ( 0.01%)  ???:0x0000000000013180 [/usr/lib/ld-linux-x86-64.so.2]
    17,336 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::max_size() const [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    16,745 ( 0.01%)  /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::detachAndGrow(QArrayData::GrowthPosition, long long, unsigned int const**, QArrayDataPointer<unsigned int>*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    16,548 ( 0.01%)  /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::data() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    16,548 ( 0.01%)  ???:QAbstractSocket::readData(char*, long long) [/usr/lib/libQt6Network.so.6.9.0]
    16,171 ( 0.01%)  /usr/include/c++/15.1.1/bits/vector.tcc:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator=(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    16,154 ( 0.01%)  /usr/include/c++/15.1.1/bits/vector.tcc:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::reserve(unsigned long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    16,154 ( 0.01%)  ???:QJsonDocument::fromJson(QByteArray const&, QJsonParseError*) [/usr/lib/libQt6Core.so.6.9.0]
    15,760 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Destroy<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    15,760 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_base() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    15,760 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::vector() [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    15,760 ( 0.01%)  ???:QJsonValue::toInt(int) const [/usr/lib/libQt6Core.so.6.9.0]
    15,366 ( 0.01%)  ???:QRingBuffer::read(char*, long long) [/usr/lib/libQt6Core.so.6.9.0]
    15,169 ( 0.01%)  /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Destroy<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*>(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    15,162 ( 0.01%)  ???:0x000000000016ed00 [/usr/lib/libc.so.6]
    15,124 ( 0.01%)  ???:0x00000000003cfaf0 [/usr/lib/libQt6Core.so.6.9.0]
    15,010 ( 0.01%)  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/dyncast.cc:__dynamic_cast [/usr/lib/libstdc++.so.6.0.34]
    14,939 ( 0.01%)  ???:0x0000000000009aa0 [/usr/lib/libEGL.so.1.1.0]
    14,578 ( 0.01%)  ../../fuse.cpp:Fuse::dataRecieve(std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > > const&, Buffer::RadarData) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    14,578 ( 0.01%)  /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QPodArrayOps<unsigned int>::createHole(QArrayData::GrowthPosition, long long, long long) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]
    14,447 ( 0.01%)  ???:0x00000000003cf9e0 [/usr/lib/libQt6Core.so.6.9.0]
    14,381 ( 0.01%)  ../../fuse.cpp:Fuse::unsafeSetRadars(Buffer::RadarData) [/home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/UTFusion]

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir                 

-- line 226 ----------------------------------------
        .              *
        .              *  This is the simple classic generic implementation.  It will work on
        .              *  temporary expressions, since they are only evaluated once, unlike a
        .              *  preprocessor macro.
        .             */
        .             template<typename _Tp>
        .               _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
        .               inline const _Tp&
    7,896 ( 0.00%)      min(const _Tp& __a, const _Tp& __b)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
        .                 //return __b < __a ? __b : __a;
   11,844 ( 0.01%)        if (__b < __a)
        .           	return __b;
    1,974 ( 0.00%)        return __a;
    3,948 ( 0.00%)      }
        .           
        .             /**
        .              *  @brief This does what you think it does.
        .              *  @ingroup sorting_algorithms
        .              *  @param  __a  A thing of arbitrary type.
        .              *  @param  __b  Another thing of arbitrary type.
        .              *  @return   The greater of the parameters.
        .              *
        .              *  This is the simple classic generic implementation.  It will work on
        .              *  temporary expressions, since they are only evaluated once, unlike a
        .              *  preprocessor macro.
        .             */
        .             template<typename _Tp>
        .               _GLIBCXX_NODISCARD _GLIBCXX14_CONSTEXPR
        .               inline const _Tp&
        4 ( 0.00%)      max(const _Tp& __a, const _Tp& __b)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
        .                 //return  __a < __b ? __b : __a;
        6 ( 0.00%)        if (__a < __b)
        2 ( 0.00%)  	return __b;
        .                 return __a;
        2 ( 0.00%)      }
        .           
        .             /**
        .              *  @brief This does what you think it does.
        .              *  @ingroup sorting_algorithms
        .              *  @param  __a  A thing of arbitrary type.
        .              *  @param  __b  Another thing of arbitrary type.
        .              *  @param  __comp  A @link comparison_functors comparison functor@endlink.
        .              *  @return   The lesser of the parameters.
-- line 274 ----------------------------------------
-- line 405 ----------------------------------------
        .                 else
        .           #endif
        .           	*__out = *__in;
        .               }
        .           
        .             template<bool _IsMove, typename _InIter, typename _Sent, typename _OutIter>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OutIter
    3,537 ( 0.00%)      __copy_move_a2(_InIter __first, _Sent __last, _OutIter __result)
        .               {
        .                 typedef __decltype(*__first) _InRef;
        .                 typedef __decltype(*__result) _OutRef;
        .                 if _GLIBCXX_CONSTEXPR (!__is_trivially_assignable(_OutRef, _InRef))
        .           	{ } /* Skip the optimizations and use the loop at the end. */
      786 ( 0.00%)        else if (std::__is_constant_evaluated())
        .           	{ } /* Skip the optimizations and use the loop at the end. */
        .                 else if _GLIBCXX_CONSTEXPR (__memcpyable<_OutIter, _InIter>::__value)
        .           	{
    1,965 ( 0.00%)  	  ptrdiff_t __n = std::distance(__first, __last);
    1,965 ( 0.00%)  	  if (__builtin_expect(__n > 1, true))
        .           	    {
    3,148 ( 0.00%)  	      __builtin_memmove(_GLIBCXX_TO_ADDR(__result),
    4,312 ( 0.00%)  => ???:0x000000000016bf80 (196x)
        .           				_GLIBCXX_TO_ADDR(__first),
      393 ( 0.00%)  				__n * sizeof(*__first));
    2,358 ( 0.00%)  	      _GLIBCXX_ADVANCE(__result, __n);
        .           	    }
        .           	  else if (__n == 1)
        .           	    {
        .           	      std::__assign_one<_IsMove>(__result, __first);
        .           	      ++__result;
        .           	    }
      786 ( 0.00%)  	  return __result;
        .           	}
        .           #if __cpp_lib_concepts
        .                 else if constexpr (__memcpyable_iterators<_OutIter, _InIter, _Sent>)
        .           	{
        .           	  if (auto __n = __last - __first; __n > 1) [[likely]]
        .           	    {
        .           	      void* __dest = std::to_address(__result);
        .           	      const void* __src = std::to_address(__first);
-- line 444 ----------------------------------------
-- line 456 ----------------------------------------
        .           	    }
        .           	  return __result;
        .           	}
        .           #endif
        .           
        .                 for (; __first != __last; ++__result, (void)++__first)
        .           	std::__assign_one<_IsMove>(__result, __first);
        .                 return __result;
    1,965 ( 0.00%)      }
        .           #pragma GCC diagnostic pop
        .           
        .             template<bool _IsMove,
        .           	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
        .               _OI
        .               __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
        .           		   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
        .           		   _OI);
-- line 472 ----------------------------------------
-- line 484 ----------------------------------------
        .                 _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
        .               __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
        .           
        .             template<bool _IsMove, typename _II, typename _OI>
        .               __attribute__((__always_inline__))
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
        .               __copy_move_a1(_II __first, _II __last, _OI __result)
    3,144 ( 0.00%)      { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
   13,935 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_algobase.h:Fusion::RadarData* std::__copy_move_a2<true, Fusion::RadarData*, Fusion::RadarData*, Fusion::RadarData*>(Fusion::RadarData*, Fusion::RadarData*, Fusion::RadarData*) (197x)
        .           
        .             template<bool _IsMove, typename _II, typename _OI>
        .               __attribute__((__always_inline__))
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
        .               __copy_move_a(_II __first, _II __last, _OI __result)
        .               {
    1,178 ( 0.00%)        return std::__niter_wrap(__result,
    6,468 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_iterator.h:__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > std::__niter_wrap<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*>(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*) (196x)
        .           		std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
        .           					     std::__niter_base(__last),
      393 ( 0.00%)  					     std::__niter_base(__result)));
        .               }
        .           
        .             template<bool _IsMove,
        .           	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               _OI
        .               __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
-- line 511 ----------------------------------------
-- line 625 ----------------------------------------
        .              *  [first,last); the copy_backward function should be used instead.
        .              *
        .              *  Note that the end of the output range is permitted to be contained
        .              *  within [first,last).
        .             */
        .             template<typename _II, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
    1,960 ( 0.00%)      copy(_II __first, _II __last, _OI __result)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_InputIteratorConcept<_II>)
        .                 __glibcxx_function_requires(_OutputIteratorConcept<_OI,
        .           	    typename iterator_traits<_II>::reference>)
        .                 __glibcxx_requires_can_increment_range(__first, __last, __result);
        .           
        .                 return std::__copy_move_a<__is_move_iterator<_II>::__value>
    2,548 ( 0.00%)  	     (std::__miter_base(__first), std::__miter_base(__last), __result);
    2,352 ( 0.00%)  => /usr/include/c++/15.1.1/bits/cpp_type_traits.h:__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > std::__miter_base<__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > >(__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >) (392x)
    1,176 ( 0.00%)      }
        .           
        .           #if __cplusplus >= 201103L
        .             /**
        .              *  @brief Moves the range [first,last) into result.
        .              *  @ingroup mutating_algorithms
        .              *  @param  __first  An input iterator.
        .              *  @param  __last   An input iterator.
        .              *  @param  __result An output iterator.
-- line 651 ----------------------------------------
-- line 658 ----------------------------------------
        .              *  [first,last); the move_backward function should be used instead.
        .              *
        .              *  Note that the end of the output range is permitted to be contained
        .              *  within [first,last).
        .             */
        .             template<typename _II, typename _OI>
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
    1,970 ( 0.00%)      move(_II __first, _II __last, _OI __result)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_InputIteratorConcept<_II>)
        .                 __glibcxx_function_requires(_OutputIteratorConcept<_OI,
        .           	    typename iterator_traits<_II>::value_type&&>)
        .                 __glibcxx_requires_can_increment_range(__first, __last, __result);
        .           
    2,167 ( 0.00%)        return std::__copy_move_a<true>(std::__miter_base(__first),
    2,364 ( 0.00%)  => /usr/include/c++/15.1.1/bits/cpp_type_traits.h:__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > std::__miter_base<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >) (394x)
        .           				      std::__miter_base(__last), __result);
    1,182 ( 0.00%)      }
        .           
        .           #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
        .           #else
        .           #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
        .           #endif
        .           
        .           #pragma GCC diagnostic push
        .           #pragma GCC diagnostic ignored "-Wc++17-extensions"
-- line 684 ----------------------------------------
-- line 889 ----------------------------------------
        .           #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
        .           #endif
        .           
        .           #pragma GCC diagnostic push
        .           #pragma GCC diagnostic ignored "-Wc++17-extensions"
        .             template<typename _ForwardIterator, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline void
      990 ( 0.00%)      __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
        .           	      const _Tp& __value)
        .               {
        .           #pragma GCC diagnostic push
        .           #pragma GCC diagnostic ignored "-Wlong-long"
        .                 // We can optimize this loop by moving the load from __value outside
        .                 // the loop, but only if we know that making that copy is trivial,
        .                 // and the assignment in the loop is also trivial (so that the identity
        .                 // of the operand doesn't matter).
      198 ( 0.00%)        const bool __load_outside_loop =
        .           #if __has_builtin(__is_trivially_constructible) \
        .                 && __has_builtin(__is_trivially_assignable)
        .           	    __is_trivially_constructible(_Tp, const _Tp&)
        .           	    && __is_trivially_assignable(__decltype(*__first), const _Tp&)
        .           #else
        .           	    __is_trivially_copyable(_Tp)
        .           	    && __is_same(_Tp, __typeof__(*__first))
        .           #endif
-- line 914 ----------------------------------------
-- line 915 ----------------------------------------
        .           	    && sizeof(_Tp) <= sizeof(long long);
        .           #pragma GCC diagnostic pop
        .           
        .                 // When the condition is true, we use a copy of __value,
        .                 // otherwise we just use another reference.
        .                 typedef typename __gnu_cxx::__conditional_type<__load_outside_loop,
        .           						     const _Tp,
        .           						     const _Tp&>::__type _Up;
      593 ( 0.00%)        _Up __val(__value);
7,880,812 ( 3.68%)        for (; __first != __last; ++__first)
5,910,030 ( 2.76%)  	*__first = __val;
      792 ( 0.00%)      }
        .           #pragma GCC diagnostic pop
        .           
        .             // Specialization: for char types we can use memset.
        .             template<typename _Up, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               inline typename
        .               __gnu_cxx::__enable_if<__is_byte<_Up>::__value
        .           			     && (__are_same<_Up, _Tp>::__value // for std::byte
-- line 934 ----------------------------------------
-- line 971 ----------------------------------------
        .             __fill_a1(_GLIBCXX_STD_C::_Bit_iterator, _GLIBCXX_STD_C::_Bit_iterator,
        .           	    const bool&);
        .           
        .             template<typename _FIte, typename _Tp>
        .               __attribute__((__always_inline__))
        .               _GLIBCXX20_CONSTEXPR
        .               inline void
        .               __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    1,386 ( 0.00%)      { std::__fill_a1(__first, __last, __value); }
13,793,349 ( 6.45%)  => /usr/include/c++/15.1.1/bits/stl_algobase.h:void std::__fill_a1<bool*, bool>(bool*, bool*, bool const&) (197x)
        .           
        .             template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
        .               _GLIBCXX20_CONSTEXPR
        .               void
        .               __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
        .           	     const _Tp&);
        .           
-- line 987 ----------------------------------------
-- line 1004 ----------------------------------------
        .               fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
        .           				  _ForwardIterator>)
        .                 __glibcxx_requires_valid_range(__first, __last);
        .           
        .                 std::__fill_a(__first, __last, __value);
      197 ( 0.00%)      }
        .           
        .           #pragma GCC diagnostic push
        .           #pragma GCC diagnostic ignored "-Wlong-long"
        .             // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
        .             inline _GLIBCXX_CONSTEXPR int
        .             __size_to_integer(int __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR unsigned
        .             __size_to_integer(unsigned __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR long
        .             __size_to_integer(long __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR unsigned long
        6 ( 0.00%)    __size_to_integer(unsigned long __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR long long
        .             __size_to_integer(long long __n) { return __n; }
        .             inline _GLIBCXX_CONSTEXPR unsigned long long
        .             __size_to_integer(unsigned long long __n) { return __n; }
        .           
        .           #if defined(__GLIBCXX_TYPE_INT_N_0)
        .             __extension__ inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
        .             __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
-- line 1032 ----------------------------------------
-- line 1135 ----------------------------------------
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OutputIterator
        .               __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        .           	       std::random_access_iterator_tag)
        .               {
        .           #if __cplusplus >= 201103L
        .                 static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
        .           #endif
        2 ( 0.00%)        if (__n <= 0)
        .           	return __first;
        .           
        .                 __glibcxx_requires_can_increment(__first, __n);
        .           
       10 ( 0.00%)        std::__fill_a(__first, __first + __n, __value);
        5 ( 0.00%)        return __first + __n;
        .               }
        .           
        .             /**
        .              *  @brief Fills the range [first,first+n) with copies of value.
        .              *  @ingroup mutating_algorithms
        .              *  @param  __first  An output iterator.
        .              *  @param  __n      The count of copies to perform.
        .              *  @param  __value  A reference-to-const of arbitrary type.
-- line 1157 ----------------------------------------
-- line 1170 ----------------------------------------
        .               __attribute__((__always_inline__))
        .               _GLIBCXX20_CONSTEXPR
        .               inline _OI
        .               fill_n(_OI __first, _Size __n, const _Tp& __value)
        .               {
        .                 // concept requirements
        .                 __glibcxx_function_requires(_OutputIteratorConcept<_OI, const _Tp&>)
        .           
        8 ( 0.00%)        return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
        6 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_algobase.h:std::__size_to_integer(unsigned long) (1x)
        1 ( 0.00%)  			       std::__iterator_category(__first));
        .               }
        .           
        .             template<bool _BoolType>
        .               struct __equal
        .               {
        .                 template<typename _II1, typename _II2>
        .           	_GLIBCXX20_CONSTEXPR
        .           	static bool
-- line 1187 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qstring.h
--------------------------------------------------------------------------------
Ir               

-- line 914 ----------------------------------------
      .               QString(char (&)[N]) = delete;
      .               template <qsizetype N>
      .               inline QString &operator=(const char (&ch)[N])
      .               { return (*this = fromUtf8(ch, N - 1)); }
      .               template <qsizetype N>
      .               QString &operator=(char (&)[N]) = delete;
      .           #endif
      .           #if !defined(QT_NO_CAST_FROM_ASCII) && !defined(QT_RESTRICTED_CAST_FROM_ASCII)
314,432 ( 0.15%)      QT_ASCII_CAST_WARN inline QString(const char *ch)
471,652 ( 0.22%)          : QString(fromUtf8(ch))
8,156,375 ( 3.81%)  => ???:QString::fromUtf8(QByteArrayView) (39,303x)
5,490,846 ( 2.57%)  => /usr/include/qt6/QtCore/qbytearrayview.h:QByteArrayView::QByteArrayView<char const*, true>(char const* const&) (39,304x)
  1,364 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
235,824 ( 0.11%)      {}
      .               QT_ASCII_CAST_WARN inline QString(const QByteArray &a)
      .                   : QString(fromUtf8(a))
      .               {}
      .               QT_ASCII_CAST_WARN inline QString &operator=(const char *ch)
      .               {
      .                   if (!ch) {
      .                       clear();
      .                       return *this;
-- line 932 ----------------------------------------
-- line 1402 ----------------------------------------
      .                   Q_UNREACHABLE_RETURN(QString());
      .           #else
      .                   return fromUcs4(reinterpret_cast<const char32_t *>(string), size);
      .           #endif
      .               }
      .           }
      .           
      .           constexpr QString::QString() noexcept {}
393,040 ( 0.18%)  QString::~QString() {}
7,861,930 ( 3.67%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<char16_t>::~QArrayDataPointer() (39,304x)
      .           
      .           void QString::reserve(qsizetype asize)
      .           {
      .               if (d.needsDetach() || asize >= capacity() - d.freeSpaceAtBegin())
      .                   reallocData(qMax(asize, size()), QArrayData::KeepSize);
      .               if (d.constAllocatedCapacity())
      .                   d.setFlag(Data::CapacityReserved);
      .           }
-- line 1418 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qbasicatomic.h
--------------------------------------------------------------------------------
Ir               

-- line 28 ----------------------------------------
      .               // static check that this is a valid integer
      .               static_assert(std::is_integral_v<T>, "template parameter is not an integral type");
      .               static_assert(QAtomicOpsSupport<sizeof(T)>::IsSupported, "template parameter is an integral of a size not supported on this platform");
      .           
      .               typename Ops::Type _q_value;
      .           
      .               // Everything below is either implemented in ../arch/qatomic_XXX.h or (as
      .               // fallback) in qgenericatomic.h
403,686 ( 0.19%)      T loadRelaxed() const noexcept { return Ops::loadRelaxed(_q_value); }
1,525,036 ( 0.71%)  => /usr/include/qt6/QtCore/qatomic_cxx11.h:int QAtomicOps<int>::loadRelaxed<int>(std::atomic<int> const&) (44,854x)
      .               void storeRelaxed(T newValue) noexcept { Ops::storeRelaxed(_q_value, newValue); }
      .           
      .               T loadAcquire() const noexcept { return Ops::loadAcquire(_q_value); }
      .               void storeRelease(T newValue) noexcept { Ops::storeRelease(_q_value, newValue); }
      .               operator T() const noexcept { return loadAcquire(); }
      .               T operator=(T newValue) noexcept { storeRelease(newValue); return newValue; }
      .           
      .               static constexpr bool isReferenceCountingNative() noexcept { return Ops::isReferenceCountingNative(); }
      .               static constexpr bool isReferenceCountingWaitFree() noexcept { return Ops::isReferenceCountingWaitFree(); }
      .           
      .               bool ref() noexcept { return Ops::ref(_q_value); }
357,345 ( 0.17%)      bool deref() noexcept { return Ops::deref(_q_value); }
635,280 ( 0.30%)  => /usr/include/qt6/QtCore/qatomic_cxx11.h:bool QAtomicOps<int>::deref<int>(std::atomic<int>&) (39,705x)
      .           
      .               static constexpr bool isTestAndSetNative() noexcept { return Ops::isTestAndSetNative(); }
      .               static constexpr bool isTestAndSetWaitFree() noexcept { return Ops::isTestAndSetWaitFree(); }
      .           
      .               bool testAndSetRelaxed(T expectedValue, T newValue) noexcept
      .               { return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue); }
      .               bool testAndSetAcquire(T expectedValue, T newValue) noexcept
      .               { return Ops::testAndSetAcquire(_q_value, expectedValue, newValue); }
-- line 56 ----------------------------------------
-- line 145 ----------------------------------------
      .               { return fetchAndAndOrdered(v) & v; }
      .               T operator|=(T v) noexcept
      .               { return fetchAndOrOrdered(v) | v; }
      .               T operator^=(T v) noexcept
      .               { return fetchAndXorOrdered(v) ^ v; }
      .           
      .           
      .               QBasicAtomicInteger() = default;
     91 ( 0.00%)      constexpr QBasicAtomicInteger(T value) noexcept : _q_value(value) {}
    161 ( 0.00%)  => /usr/include/c++/15.1.1/atomic:std::atomic<int>::atomic(int) (7x)
      .               QBasicAtomicInteger(const QBasicAtomicInteger &) = delete;
      .               QBasicAtomicInteger &operator=(const QBasicAtomicInteger &) = delete;
      .               QBasicAtomicInteger &operator=(const QBasicAtomicInteger &) volatile = delete;
      .           };
      .           typedef QBasicAtomicInteger<int> QBasicAtomicInt;
      .           
      .           template <typename X>
      .           class QBasicAtomicPointer
-- line 161 ----------------------------------------
-- line 162 ----------------------------------------
      .           {
      .           public:
      .               typedef X *Type;
      .               typedef QAtomicOps<Type> Ops;
      .               typedef typename Ops::Type AtomicType;
      .           
      .               AtomicType _q_value;
      .           
  3,546 ( 0.00%)      Type loadRelaxed() const noexcept { return Ops::loadRelaxed(_q_value); }
 18,124 ( 0.01%)  => /usr/include/qt6/QtCore/qatomic_cxx11.h:QMutexPrivate* QAtomicOps<QMutexPrivate*>::loadRelaxed<QMutexPrivate*>(std::atomic<QMutexPrivate*> const&) (394x)
      .               void storeRelaxed(Type newValue) noexcept { Ops::storeRelaxed(_q_value, newValue); }
      .           
      .               operator Type() const noexcept { return loadAcquire(); }
      .               Type operator=(Type newValue) noexcept { storeRelease(newValue); return newValue; }
      .           
      .               // Atomic API, implemented in qatomic_XXX.h
      .               Type loadAcquire() const noexcept { return Ops::loadAcquire(_q_value); }
      .               void storeRelease(Type newValue) noexcept { Ops::storeRelease(_q_value, newValue); }
      .           
      .               static constexpr bool isTestAndSetNative() noexcept { return Ops::isTestAndSetNative(); }
      .               static constexpr bool isTestAndSetWaitFree() noexcept { return Ops::isTestAndSetWaitFree(); }
      .           
      .               bool testAndSetRelaxed(Type expectedValue, Type newValue) noexcept
      .               { return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue); }
  1,182 ( 0.00%)      bool testAndSetAcquire(Type expectedValue, Type newValue) noexcept
  1,576 ( 0.00%)      { return Ops::testAndSetAcquire(_q_value, expectedValue, newValue); }
 18,715 ( 0.01%)  => /usr/include/qt6/QtCore/qatomic_cxx11.h:bool QAtomicOps<QMutexPrivate*>::testAndSetAcquire<QMutexPrivate*>(std::atomic<QMutexPrivate*>&, QMutexPrivate*, QMutexPrivate*, QMutexPrivate**) (197x)
  1,182 ( 0.00%)      bool testAndSetRelease(Type expectedValue, Type newValue) noexcept
  1,576 ( 0.00%)      { return Ops::testAndSetRelease(_q_value, expectedValue, newValue); }
 18,715 ( 0.01%)  => /usr/include/qt6/QtCore/qatomic_cxx11.h:bool QAtomicOps<QMutexPrivate*>::testAndSetRelease<QMutexPrivate*>(std::atomic<QMutexPrivate*>&, QMutexPrivate*, QMutexPrivate*, QMutexPrivate**) (197x)
      .               bool testAndSetOrdered(Type expectedValue, Type newValue) noexcept
      .               { return Ops::testAndSetOrdered(_q_value, expectedValue, newValue); }
      .           
      .               bool testAndSetRelaxed(Type expectedValue, Type newValue, Type &currentValue) noexcept
      .               { return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue, &currentValue); }
      .               bool testAndSetAcquire(Type expectedValue, Type newValue, Type &currentValue) noexcept
      .               { return Ops::testAndSetAcquire(_q_value, expectedValue, newValue, &currentValue); }
      .               bool testAndSetRelease(Type expectedValue, Type newValue, Type &currentValue) noexcept
-- line 196 ----------------------------------------
-- line 240 ----------------------------------------
      .               Type operator--(int) noexcept
      .               { return fetchAndSubOrdered(1); }
      .               Type operator+=(qptrdiff valueToAdd) noexcept
      .               { return fetchAndAddOrdered(valueToAdd) + valueToAdd; }
      .               Type operator-=(qptrdiff valueToSub) noexcept
      .               { return fetchAndSubOrdered(valueToSub) - valueToSub; }
      .           
      .               QBasicAtomicPointer() = default;
     26 ( 0.00%)      constexpr QBasicAtomicPointer(Type value) noexcept : _q_value(value) {}
     46 ( 0.00%)  => /usr/include/c++/15.1.1/atomic:std::atomic<QMutexPrivate*>::atomic(QMutexPrivate*) (2x)
      .               QBasicAtomicPointer(const QBasicAtomicPointer &) = delete;
      .               QBasicAtomicPointer &operator=(const QBasicAtomicPointer &) = delete;
      .               QBasicAtomicPointer &operator=(const QBasicAtomicPointer &) volatile = delete;
      .           };
      .           
      .           #ifndef Q_BASIC_ATOMIC_INITIALIZER
      .           #  define Q_BASIC_ATOMIC_INITIALIZER(a) { (a) }
      .           #endif
-- line 256 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qlist.h
--------------------------------------------------------------------------------
Ir              

-- line 68 ----------------------------------------
     .           #define QT_STRICT_QLIST_ITERATORS
     .           #endif
     .           
     .           #ifdef Q_QDOC // define QVector for QDoc
     .           template<typename T> class QVector : public QList<T> {};
     .           #endif
     .           
     .           template <typename T>
 1,970 ( 0.00%)  class QList
39,503 ( 0.02%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::~QArrayDataPointer() (197x)
     .           #ifndef Q_QDOC
     .               : public QListSpecialMethods<T>
     .           #endif
     .           {
     .               using Data = QTypedArrayData<T>;
     .               using DataOps = QArrayDataOps<T>;
     .               using DataPointer = QArrayDataPointer<T>;
     .               class DisableRValueRefs {};
-- line 84 ----------------------------------------
-- line 111 ----------------------------------------
     .           #endif
     .           
     .               class const_iterator;
     .               class iterator {
     .                   friend class QList<T>;
     .                   friend class const_iterator;
     .                   T *i = nullptr;
     .           #ifdef QT_STRICT_QLIST_ITERATORS
35,460 ( 0.02%)          inline constexpr explicit iterator(T *n) : i(n) {}
     .           #endif
     .           
     .               public:
     .                   using difference_type = qsizetype;
     .                   using value_type = T;
     .           #ifdef QT_COMPILER_HAS_LWG3346
     .                   using iterator_concept = std::contiguous_iterator_tag;
     .           #endif
-- line 127 ----------------------------------------
-- line 129 ----------------------------------------
     .                   using iterator_category = std::random_access_iterator_tag;
     .                   using pointer = T *;
     .                   using reference = T &;
     .           
     .                   inline constexpr iterator() = default;
     .           #ifndef QT_STRICT_QLIST_ITERATORS
     .                   inline constexpr explicit iterator(T *n) : i(n) {}
     .           #endif
12,411 ( 0.01%)          inline T &operator*() const { return *i; }
     .                   inline T *operator->() const { return i; }
     .                   inline T &operator[](qsizetype j) const { return *(i + j); }
     .                   inline constexpr bool operator==(iterator o) const { return i == o.i; }
     .                   inline constexpr bool operator!=(iterator o) const { return i != o.i; }
     .                   inline constexpr bool operator<(iterator other) const { return i < other.i; }
     .                   inline constexpr bool operator<=(iterator other) const { return i <= other.i; }
     .                   inline constexpr bool operator>(iterator other) const { return i > other.i; }
     .                   inline constexpr bool operator>=(iterator other) const { return i >= other.i; }
-- line 145 ----------------------------------------
-- line 171 ----------------------------------------
     .                   template <typename Int> std::enable_if_t<std::is_integral_v<Int>, iterator>
     .                   operator-(Int j) const { return iterator(i-j); }
     .                   template <typename Int> friend std::enable_if_t<std::is_integral_v<Int>, iterator>
     .                   operator+(Int j, iterator k) { return k + j; }
     .           #else
     .                   inline iterator &operator+=(qsizetype j) { i += j; return *this; }
     .                   inline iterator &operator-=(qsizetype j) { i -= j; return *this; }
     .                   inline iterator operator+(qsizetype j) const { return iterator(i + j); }
43,143 ( 0.02%)          inline iterator operator-(qsizetype j) const { return iterator(i - j); }
 1,970 ( 0.00%)  => /usr/include/qt6/QtCore/qlist.h:QList<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::iterator::iterator(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*) (197x)
     .                   friend inline iterator operator+(qsizetype j, iterator k) { return k + j; }
     .           #endif
     .               };
     .           
     .               class const_iterator {
     .                   friend class QList<T>;
     .                   friend class iterator;
     .                   const T *i = nullptr;
-- line 187 ----------------------------------------
-- line 273 ----------------------------------------
     .               }
     .           public:
     .               QList(DataPointer dd) noexcept
     .                   : d(dd)
     .               {
     .               }
     .           
     .           public:
    10 ( 0.00%)      constexpr QList() noexcept = default;
    12 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::QArrayDataPointer() (1x)
     .               explicit QList(qsizetype size)
     .                   : d(size)
     .               {
     .                   if (size)
     .                       d->appendInitialize(size);
     .               }
     .               QList(qsizetype size, parameter_type t)
     .                   : d(size)
-- line 289 ----------------------------------------
-- line 449 ----------------------------------------
     .                   if (size > this->size())
     .                       d->appendUninitialized(size);
     .               }
     .           
     .               inline qsizetype capacity() const { return qsizetype(d->constAllocatedCapacity()); }
     .               void reserve(qsizetype size);
     .               inline void squeeze();
     .           
32,505 ( 0.02%)      void detach() { d.detach(); }
16,548 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::detach(QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*) (197x)
     .               bool isDetached() const noexcept { return !d->isShared(); }
     .           
     .               inline bool isSharedWith(const QList<T> &other) const { return d == other.d; }
     .           
16,548 ( 0.01%)      pointer data() { detach(); return d->data(); }
112,290 ( 0.05%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::detach() (1,182x)
 8,274 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::data() (1,182x)
 7,092 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::operator->() (1,182x)
     .               const_pointer data() const noexcept { return d->data(); }
     .               const_pointer constData() const noexcept { return d->data(); }
     .               void clear() {
     .                   if (!size())
     .                       return;
     .                   if (d->needsDetach()) {
     .                       // must allocate memory
     .                       DataPointer detached(d.allocatedCapacity());
-- line 470 ----------------------------------------
-- line 474 ----------------------------------------
     .                   }
     .               }
     .           
     .               const_reference at(qsizetype i) const noexcept
     .               {
     .                   Q_ASSERT_X(size_t(i) < size_t(d->size), "QList::at", "index out of range");
     .                   return data()[i];
     .               }
 5,910 ( 0.00%)      reference operator[](qsizetype i)
     .               {
 9,456 ( 0.00%)          Q_ASSERT_X(size_t(i) < size_t(d->size), "QList::operator[]", "index out of range");
 7,092 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::operator->() (1,182x)
     .                   // don't detach() here, we detach in data below:
 7,092 ( 0.00%)          return data()[i];
144,204 ( 0.07%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::data() (1,182x)
 2,364 ( 0.00%)      }
     .               const_reference operator[](qsizetype i) const noexcept { return at(i); }
23,049 ( 0.01%)      void append(parameter_type t) { emplaceBack(t); }
302,825 ( 0.14%)  => /usr/include/qt6/QtCore/qlist.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >& QList<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::emplaceBack<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const&>(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const&) (197x)
     .               void append(const_iterator i1, const_iterator i2);
     .               void append(rvalue_ref t)
     .               {
     .                   if constexpr (DataPointer::pass_parameter_by_value) {
     .                       Q_UNUSED(t);
     .                   } else {
     .                       emplaceBack(std::move(t));
     .                   }
-- line 497 ----------------------------------------
-- line 649 ----------------------------------------
     .                   if (from < to)
     .                       std::rotate(b + from, b + from + 1, b + to + 1);
     .                   else
     .                       std::rotate(b + to, b + from, b + from + 1);
     .               }
     .           
     .               // STL-style
     .               iterator begin() { detach(); return iterator(d->begin()); }
46,098 ( 0.02%)      iterator end() { detach(); return iterator(d->end()); }
18,715 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::detach() (197x)
 4,925 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::end() (197x)
 1,970 ( 0.00%)  => /usr/include/qt6/QtCore/qlist.h:QList<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::iterator::iterator(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*) (197x)
 1,182 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::operator->() (197x)
     .           
     .               const_iterator begin() const noexcept { return const_iterator(d->constBegin()); }
     .               const_iterator end() const noexcept { return const_iterator(d->constEnd()); }
     .               const_iterator cbegin() const noexcept { return const_iterator(d->constBegin()); }
     .               const_iterator cend() const noexcept { return const_iterator(d->constEnd()); }
     .               const_iterator constBegin() const noexcept { return const_iterator(d->constBegin()); }
     .               const_iterator constEnd() const noexcept { return const_iterator(d->constEnd()); }
     .               reverse_iterator rbegin() { return reverse_iterator(end()); }
-- line 665 ----------------------------------------
-- line 905 ----------------------------------------
     .           {
     .               Q_ASSERT_X(i >= 0 && i <= d->size, "QList<T>::insert", "index out of range");
     .               d->emplace(i, std::forward<Args>(args)...);
     .               return begin() + i;
     .           }
     .           
     .           template<typename T>
     .           template<typename... Args>
17,730 ( 0.01%)  inline typename QList<T>::reference QList<T>::emplaceBack(Args &&... args)
     .           {
24,822 ( 0.01%)      d->emplace(d->size, std::forward<Args>(args)...);
251,014 ( 0.12%)  => /usr/include/qt6/QtCore/qarraydataops.h:void QtPrivate::QGenericArrayOps<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::emplace<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const&>(long long, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const&) (197x)
 2,364 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::operator->() (394x)
21,276 ( 0.01%)      return *(end() - 1);
31,914 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::end() (197x)
 7,289 ( 0.00%)  => /usr/include/qt6/QtCore/qlist.h:QList<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::iterator::operator-(long long) const (197x)
 1,379 ( 0.00%)  => /usr/include/qt6/QtCore/qlist.h:QList<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::iterator::operator*() const (197x)
14,184 ( 0.01%)  }
     .           
     .           template <typename T>
     .           typename QList<T>::iterator QList<T>::erase(const_iterator abegin, const_iterator aend)
     .           {
     .               Q_ASSERT_X(isValidIterator(abegin), "QList::erase", "The specified iterator argument 'abegin' is invalid");
     .               Q_ASSERT_X(isValidIterator(aend), "QList::erase", "The specified iterator argument 'aend' is invalid");
     .               Q_ASSERT(aend >= abegin);
     .           
-- line 925 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/atomic_base.h
--------------------------------------------------------------------------------
Ir               

-- line 103 ----------------------------------------
      .             constexpr memory_order
      .             operator|(memory_order __m, __memory_order_modifier __mod) noexcept
      .             {
      .               return memory_order(int(__m) | int(__mod));
      .             }
      .           
      .             constexpr memory_order
      .             operator&(memory_order __m, __memory_order_modifier __mod) noexcept
184,144 ( 0.09%)    {
 92,072 ( 0.04%)      return memory_order(int(__m) & int(__mod));
 92,072 ( 0.04%)    }
      .           
      .             /// @cond undocumented
      .           
      .             // Drop release ordering as per [atomics.types.operations.req]/21
      .             constexpr memory_order
      .             __cmpexch_failure_order2(memory_order __m) noexcept
      .             {
      .               return __m == memory_order_acq_rel ? memory_order_acquire
-- line 121 ----------------------------------------
-- line 126 ----------------------------------------
      .             __cmpexch_failure_order(memory_order __m) noexcept
      .             {
      .               return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)
      .                 | __memory_order_modifier(__m & __memory_order_modifier_mask));
      .             }
      .           
      .             constexpr bool
      .             __is_valid_cmpexch_failure_order(memory_order __m) noexcept
  1,576 ( 0.00%)    {
  1,576 ( 0.00%)      return (__m & __memory_order_mask) != memory_order_release
  3,152 ( 0.00%)  => /usr/include/c++/15.1.1/bits/atomic_base.h:std::operator&(std::memory_order, std::__memory_order_modifier) (394x)
  3,940 ( 0.00%)  	&& (__m & __memory_order_mask) != memory_order_acq_rel;
  3,152 ( 0.00%)  => /usr/include/c++/15.1.1/bits/atomic_base.h:std::operator&(std::memory_order, std::__memory_order_modifier) (394x)
    788 ( 0.00%)    }
      .           
      .             // Base types for atomics.
      .             template<typename _IntTp>
      .               struct __atomic_base;
      .           
      .             /// @endcond
      .           
      .             _GLIBCXX_ALWAYS_INLINE void
-- line 145 ----------------------------------------
-- line 350 ----------------------------------------
      .           
      .               public:
      .                 __atomic_base() noexcept = default;
      .                 ~__atomic_base() noexcept = default;
      .                 __atomic_base(const __atomic_base&) = delete;
      .                 __atomic_base& operator=(const __atomic_base&) = delete;
      .                 __atomic_base& operator=(const __atomic_base&) volatile = delete;
      .           
     70 ( 0.00%)        constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
      .           
      .                 operator __int_type() const noexcept
      .                 { return load(); }
      .           
      .                 operator __int_type() const volatile noexcept
      .                 { return load(); }
      .           
      .                 __int_type
-- line 366 ----------------------------------------
-- line 489 ----------------------------------------
      .           
      .           	__atomic_store_n(&_M_i, __i, int(__m));
      .                 }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE __int_type
      .                 load(memory_order __m = memory_order_seq_cst) const noexcept
      .                 {
      .           	memory_order __b __attribute__ ((__unused__))
224,270 ( 0.10%)  	  = __m & __memory_order_mask;
358,832 ( 0.17%)  => /usr/include/c++/15.1.1/bits/atomic_base.h:std::operator&(std::memory_order, std::__memory_order_modifier) (44,854x)
224,270 ( 0.10%)  	__glibcxx_assert(__b != memory_order_release);
224,270 ( 0.10%)  	__glibcxx_assert(__b != memory_order_acq_rel);
      .           
 89,708 ( 0.04%)  	return __atomic_load_n(&_M_i, int(__m));
      .                 }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE __int_type
      .                 load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      .                 {
      .           	memory_order __b __attribute__ ((__unused__))
      .           	  = __m & __memory_order_mask;
      .           	__glibcxx_assert(__b != memory_order_release);
-- line 509 ----------------------------------------
-- line 633 ----------------------------------------
      .                 _GLIBCXX_ALWAYS_INLINE __int_type
      .                 fetch_add(__int_type __i,
      .           		memory_order __m = memory_order_seq_cst) volatile noexcept
      .                 { return __atomic_fetch_add(&_M_i, __i, int(__m)); }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE __int_type
      .                 fetch_sub(__int_type __i,
      .           		memory_order __m = memory_order_seq_cst) noexcept
198,525 ( 0.09%)        { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE __int_type
      .                 fetch_sub(__int_type __i,
      .           		memory_order __m = memory_order_seq_cst) volatile noexcept
      .                 { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE __int_type
      .                 fetch_and(__int_type __i,
-- line 649 ----------------------------------------
-- line 693 ----------------------------------------
      .               public:
      .                 __atomic_base() noexcept = default;
      .                 ~__atomic_base() noexcept = default;
      .                 __atomic_base(const __atomic_base&) = delete;
      .                 __atomic_base& operator=(const __atomic_base&) = delete;
      .                 __atomic_base& operator=(const __atomic_base&) volatile = delete;
      .           
      .                 // Requires __pointer_type convertible to _M_p.
     20 ( 0.00%)        constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
      .           
      .                 operator __pointer_type() const noexcept
      .                 { return load(); }
      .           
      .                 operator __pointer_type() const volatile noexcept
      .                 { return load(); }
      .           
      .                 __pointer_type
-- line 709 ----------------------------------------
-- line 818 ----------------------------------------
      .           
      .           	__atomic_store_n(&_M_p, __p, int(__m));
      .                 }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE __pointer_type
      .                 load(memory_order __m = memory_order_seq_cst) const noexcept
      .                 {
      .           	memory_order __b __attribute__ ((__unused__))
  1,970 ( 0.00%)  	  = __m & __memory_order_mask;
  3,152 ( 0.00%)  => /usr/include/c++/15.1.1/bits/atomic_base.h:std::operator&(std::memory_order, std::__memory_order_modifier) (394x)
  1,970 ( 0.00%)  	__glibcxx_assert(__b != memory_order_release);
  1,970 ( 0.00%)  	__glibcxx_assert(__b != memory_order_acq_rel);
      .           
    788 ( 0.00%)  	return __atomic_load_n(&_M_p, int(__m));
      .                 }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE __pointer_type
      .                 load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      .                 {
      .           	memory_order __b __attribute__ ((__unused__))
      .           	  = __m & __memory_order_mask;
      .           	__glibcxx_assert(__b != memory_order_release);
-- line 838 ----------------------------------------
-- line 878 ----------------------------------------
      .           					   int(__m1), int(__m2));
      .                 }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE bool
      .                 compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
      .           			      memory_order __m1,
      .           			      memory_order __m2) noexcept
      .                 {
  3,546 ( 0.00%)  	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
 14,184 ( 0.01%)  => /usr/include/c++/15.1.1/bits/atomic_base.h:std::__is_valid_cmpexch_failure_order(std::memory_order) (394x)
      .           
  3,546 ( 0.00%)  	return __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,
    394 ( 0.00%)  					   int(__m1), int(__m2));
      .                 }
      .           
      .                 _GLIBCXX_ALWAYS_INLINE bool
      .                 compare_exchange_strong(__pointer_type& __p1, __pointer_type __p2,
      .           			      memory_order __m1,
      .           			      memory_order __m2) volatile noexcept
      .                 {
      .           	__glibcxx_assert(__is_valid_cmpexch_failure_order(__m2));
-- line 897 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qarraydata.h
--------------------------------------------------------------------------------
Ir               

-- line 43 ----------------------------------------
      .               ArrayOptions flags;
      .               qsizetype alloc;
      .           
      .               qsizetype allocatedCapacity() noexcept
      .               {
      .                   return alloc;
      .               }
      .           
 10,236 ( 0.00%)      qsizetype constAllocatedCapacity() const noexcept
      .               {
  6,824 ( 0.00%)          return alloc;
  6,824 ( 0.00%)      }
      .           
      .               /// Returns true if sharing took place
      .               bool ref() noexcept
      .               {
      .                   ref_.ref();
      .                   return true;
      .               }
      .           
      .               /// Returns false if deallocation is necessary
158,820 ( 0.07%)      bool deref() noexcept
      .               {
119,115 ( 0.06%)          return ref_.deref();
992,625 ( 0.46%)  => /usr/include/qt6/QtCore/qbasicatomic.h:QBasicAtomicInteger<int>::deref() (39,705x)
 79,410 ( 0.04%)      }
      .           
     28 ( 0.00%)      bool isShared() const noexcept
      .               {
     35 ( 0.00%)          return ref_.loadRelaxed() != 1;
    301 ( 0.00%)  => /usr/include/qt6/QtCore/qbasicatomic.h:QBasicAtomicInteger<int>::loadRelaxed() const (7x)
     14 ( 0.00%)      }
      .           
      .               // Returns true if a detach is necessary before modifying the data
      .               // This method is intentionally not const: if you want to know whether
      .               // detaching is necessary, you should be in a non-const function already
 20,568 ( 0.01%)      bool needsDetach() noexcept
      .               {
 25,710 ( 0.01%)          return ref_.loadRelaxed() > 1;
221,106 ( 0.10%)  => /usr/include/qt6/QtCore/qbasicatomic.h:QBasicAtomicInteger<int>::loadRelaxed() const (5,142x)
 10,284 ( 0.00%)      }
      .           
     56 ( 0.00%)      qsizetype detachCapacity(qsizetype newSize) const noexcept
      .               {
     98 ( 0.00%)          if (flags & CapacityReserved && newSize < constAllocatedCapacity())
    406 ( 0.00%)  => /usr/include/qt6/QtCore/qflags.h:QFlags<QArrayData::ArrayOption>::operator&(QArrayData::ArrayOption) const (7x)
     49 ( 0.00%)  => /usr/include/qt6/QtCore/qflags.h:QFlags<QArrayData::ArrayOption>::operator unsigned int() const (7x)
      .                       return constAllocatedCapacity();
      7 ( 0.00%)          return newSize;
     35 ( 0.00%)      }
      .           
      .               Q_DECL_MALLOCLIKE
      .               static Q_CORE_EXPORT void *allocate(QArrayData **pdata, qsizetype objectSize, qsizetype alignment,
      .                       qsizetype capacity, AllocationOption option = QArrayData::KeepSize) noexcept;
      .               Q_DECL_MALLOCLIKE
      .               static Q_CORE_EXPORT void *allocate1(QArrayData **pdata, qsizetype capacity,
      .                                                    AllocationOption option = QArrayData::KeepSize) noexcept;
      .               Q_DECL_MALLOCLIKE
-- line 95 ----------------------------------------
-- line 121 ----------------------------------------
      .           }
      .           
      .           template <class T>
      .           struct QTypedArrayData
      .               : QArrayData
      .           {
      .               struct AlignmentDummy { QtPrivate::AlignedQArrayData header; T data; };
      .           
  1,640 ( 0.00%)      [[nodiscard]] static std::pair<QTypedArrayData *, T *> allocate(qsizetype capacity, AllocationOption option = QArrayData::KeepSize)
      .               {
      .                   static_assert(sizeof(QTypedArrayData) == sizeof(QArrayData));
      .                   QArrayData *d;
      .                   void *result;
      .                   if constexpr (sizeof(T) == 1) {
      .                       // necessarily, alignof(T) == 1
      .                       result = allocate1(&d, capacity, option);
      .                   } else if constexpr (sizeof(T) == 2) {
      .                       // alignof(T) may be 1, but that makes no difference
      .                       result = allocate2(&d, capacity, option);
      .                   } else {
  2,259 ( 0.00%)              result = QArrayData::allocate(&d, sizeof(T), alignof(AlignmentDummy), capacity, option);
 20,776 ( 0.01%)  => ???:QArrayData::allocate(QArrayData**, long long, long long, long long, QArrayData::AllocationOption) (196x)
  1,346 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
      .                   }
      .           #if __has_builtin(__builtin_assume_aligned)
      .                   // and yet we do offer results that have stricter alignment
      .                   result = __builtin_assume_aligned(result, Q_ALIGNOF(AlignmentDummy));
      .           #endif
  2,460 ( 0.00%)          return {static_cast<QTypedArrayData *>(d), static_cast<T *>(result)};
  3,940 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_pair.h:std::pair<QTypedArrayData<unsigned int>*, unsigned int*>::pair<QTypedArrayData<unsigned int>*, unsigned int*, true>(QTypedArrayData<unsigned int>*&&, unsigned int*&&) (197x)
  1,025 ( 0.00%)      }
      .           
      .               static std::pair<QTypedArrayData *, T *>
  1,970 ( 0.00%)      reallocateUnaligned(QTypedArrayData *data, T *dataPointer, qsizetype capacity, AllocationOption option)
      .               {
      .                   static_assert(sizeof(QTypedArrayData) == sizeof(QArrayData));
      .                   std::pair<QArrayData *, void *> pair =
  2,368 ( 0.00%)                  QArrayData::reallocateUnaligned(data, dataPointer, sizeof(T), capacity, option);
 81,438 ( 0.04%)  => ???:QArrayData::reallocateUnaligned(QArrayData*, void*, long long, long long, QArrayData::AllocationOption) (196x)
  1,744 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
  2,364 ( 0.00%)          return {static_cast<QTypedArrayData *>(pair.first), static_cast<T *>(pair.second)};
  3,940 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_pair.h:std::pair<QTypedArrayData<unsigned int>*, unsigned int*>::pair<QTypedArrayData<unsigned int>*, unsigned int*, true>(QTypedArrayData<unsigned int>*&&, unsigned int*&&) (197x)
    985 ( 0.00%)      }
      .           
      .               static void deallocate(QArrayData *data) noexcept
      .               {
      .                   static_assert(sizeof(QTypedArrayData) == sizeof(QArrayData));
      .                   QArrayData::deallocate(data, sizeof(T), alignof(AlignmentDummy));
      .               }
      .           
 16,040 ( 0.01%)      static T *dataStart(QArrayData *data, qsizetype alignment) noexcept
      .               {
      .                   // Alignment is a power of two
 22,456 ( 0.01%)          Q_ASSERT(alignment >= qsizetype(alignof(QArrayData)) && !(alignment & (alignment - 1)));
  3,208 ( 0.00%)          void *start =  reinterpret_cast<void *>(
 22,456 ( 0.01%)              (quintptr(data) + sizeof(QArrayData) + alignment - 1) & ~(alignment - 1));
  3,208 ( 0.00%)          return static_cast<T *>(start);
  6,416 ( 0.00%)      }
      .           
      .               constexpr static qsizetype maxSize() noexcept
      .               {
      .                   // -1 to deal with the pointer one-past-the-end
      .                   return (QtPrivate::MaxAllocSize - sizeof(QtPrivate::AlignedQArrayData) - 1) / sizeof(T);
      .               }
      .               constexpr static qsizetype max_size() noexcept
      .               {
-- line 180 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/stl_uninitialized.h
--------------------------------------------------------------------------------
Ir              

-- line 105 ----------------------------------------
     .                 _UninitDestroyGuard(const _UninitDestroyGuard&);
     .               };
     .           
     .             template<typename _ForwardIterator>
     .               struct _UninitDestroyGuard<_ForwardIterator, void>
     .               {
     .                 _GLIBCXX20_CONSTEXPR
     .                 explicit
   788 ( 0.00%)        _UninitDestroyGuard(_ForwardIterator& __first)
 1,379 ( 0.00%)        : _M_first(__first), _M_cur(__builtin_addressof(__first))
   591 ( 0.00%)        { }
     .           
     .                 _GLIBCXX20_CONSTEXPR
   788 ( 0.00%)        ~_UninitDestroyGuard()
     .                 {
 1,379 ( 0.00%)  	if (__builtin_expect(_M_cur != 0, 0))
     .           	  std::_Destroy(_M_first, *_M_cur);
   591 ( 0.00%)        }
     .           
     .                 _GLIBCXX20_CONSTEXPR
 1,576 ( 0.00%)        void release() { _M_cur = 0; }
     .           
     .                 _ForwardIterator const _M_first;
     .                 _ForwardIterator* _M_cur;
     .           
     .               private:
     .                 _UninitDestroyGuard(const _UninitDestroyGuard&);
     .               };
     .           
-- line 133 ----------------------------------------
-- line 223 ----------------------------------------
     .              *  @param  __result A forward iterator.
     .              *  @return   __result + (__last - __first)
     .              *
     .              *  Like std::copy, but does not require an initialized output range.
     .             */
     .             template<typename _InputIterator, typename _ForwardIterator>
     .               _GLIBCXX26_CONSTEXPR
     .               inline _ForwardIterator
19,514 ( 0.01%)      uninitialized_copy(_InputIterator __first, _InputIterator __last,
     .           		       _ForwardIterator __result)
     .               {
     .                 // We can use memcpy to copy the ranges under these conditions:
     .                 //
     .                 // _ForwardIterator and _InputIterator are both contiguous iterators,
     .                 // so that we can turn them into pointers to pass to memcpy.
     .                 // Before C++20 we can't detect all contiguous iterators, so we only
     .                 // handle built-in pointers and __normal_iterator<T*, C> types.
-- line 239 ----------------------------------------
-- line 261 ----------------------------------------
     .                 if consteval {
     .           	return std::__do_uninit_copy(__first, __last, __result);
     .                 }
     .           #endif
     .                 if constexpr (!__is_trivially_constructible(_ValT, decltype(*__first)))
     .           	return std::__do_uninit_copy(__first, __last, __result);
     .                 else if constexpr (__memcpyable<_Dest, _Src>::__value)
     .           	{
 1,774 ( 0.00%)  	  ptrdiff_t __n = __last - __first;
 3,548 ( 0.00%)  	  if (__n > 0) [[__likely__]]
     .           	    {
     .           	      using _ValT = typename remove_pointer<_Src>::type;
22,472 ( 0.01%)  	      __builtin_memcpy(std::__niter_base(__result),
32,050 ( 0.01%)  => ???:0x000000000016bf80 (1,575x)
 1,411 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
     .           			       std::__niter_base(__first),
 1,774 ( 0.00%)  			       __n * sizeof(_ValT));
10,050 ( 0.00%)  	      __result += __n;
     .           	    }
 1,774 ( 0.00%)  	  return __result;
     .           	}
     .           #if __cpp_lib_concepts
     .                 else if constexpr (contiguous_iterator<_ForwardIterator>
     .           			   && contiguous_iterator<_InputIterator>)
     .           	{
     .           	  using _DestPtr = decltype(std::to_address(__result));
     .           	  using _SrcPtr = decltype(std::to_address(__first));
     .           	  if constexpr (__memcpyable<_DestPtr, _SrcPtr>::__value)
-- line 286 ----------------------------------------
-- line 309 ----------------------------------------
     .           
     .                 const bool __can_memcpy
     .           	= __memcpyable<_ValueType1*, _ValueType2*>::__value
     .           	    && __is_trivially_constructible(_ValueType2, __decltype(*__first));
     .           
     .                 return __uninitialized_copy<__can_memcpy>::
     .           	       __uninit_copy(__first, __last, __result);
     .           #endif
 8,870 ( 0.00%)      }
     .           #pragma GCC diagnostic pop
     .           
     .             /// @cond undocumented
     .           
     .             // This is the default implementation of std::uninitialized_fill.
     .             template<typename _ForwardIterator, typename _Tp>
     .               _GLIBCXX20_CONSTEXPR void
     .               __do_uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
-- line 325 ----------------------------------------
-- line 605 ----------------------------------------
     .                 return __result;
     .               }
     .           
     .           #if _GLIBCXX_HOSTED
     .             template<typename _InputIterator, typename _Sentinel,
     .           	   typename _ForwardIterator, typename _Tp>
     .               _GLIBCXX20_CONSTEXPR
     .               inline _ForwardIterator
12,418 ( 0.01%)      __uninitialized_copy_a(_InputIterator __first, _Sentinel __last,
     .           			   _ForwardIterator __result, allocator<_Tp>&)
     .               {
     .           #ifdef __cpp_lib_is_constant_evaluated
     .                 if (std::is_constant_evaluated())
     .           	return std::__do_uninit_copy(std::move(__first), __last, __result);
     .           #endif
     .           
     .           #ifdef __glibcxx_ranges
-- line 621 ----------------------------------------
-- line 629 ----------------------------------------
     .           					   __first + (__last - __first),
     .           					   __result);
     .           	  else // Just use default implementation.
     .           	    return std::__do_uninit_copy(std::move(__first), __last, __result);
     .           	}
     .                 else
     .           	return std::uninitialized_copy(std::move(__first), __last, __result);
     .           #else
10,644 ( 0.00%)        return std::uninitialized_copy(__first, __last, __result);
    70 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::RadarData* std::uninitialized_copy<__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*>(__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*) (1x)
     .           #endif
 3,548 ( 0.00%)      }
     .           #endif
     .           
     .             template<typename _InputIterator, typename _ForwardIterator,
     .           	   typename _Allocator>
     .               _GLIBCXX20_CONSTEXPR
     .               inline _ForwardIterator
     .               __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
     .           			   _ForwardIterator __result, _Allocator& __alloc)
-- line 647 ----------------------------------------
-- line 864 ----------------------------------------
     .               };
     .           
     .             template<bool _TrivialValueType>
     .               struct __uninitialized_default_n_1
     .               {
     .                 template<typename _ForwardIterator, typename _Size>
     .           	_GLIBCXX20_CONSTEXPR
     .                   static _ForwardIterator
 1,773 ( 0.00%)          __uninit_default_n(_ForwardIterator __first, _Size __n)
     .                   {
   985 ( 0.00%)  	  _UninitDestroyGuard<_ForwardIterator> __guard(__first);
 2,758 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:std::_UninitDestroyGuard<Fusion::FusionOutput*, void>::_UninitDestroyGuard(Fusion::FusionOutput*&) (197x)
 7,683 ( 0.00%)  	  for (; __n > 0; --__n, (void) ++__first)
 4,728 ( 0.00%)  	    std::_Construct(std::__addressof(*__first));
62,646 ( 0.03%)  => /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Construct<Fusion::FusionOutput>(Fusion::FusionOutput*) (1,182x)
   591 ( 0.00%)  	  __guard.release();
 1,576 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:std::_UninitDestroyGuard<Fusion::FusionOutput*, void>::release() (197x)
   394 ( 0.00%)  	  return __first;
 1,773 ( 0.00%)  	}
 2,758 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:std::_UninitDestroyGuard<Fusion::FusionOutput*, void>::~_UninitDestroyGuard() (197x)
     .               };
     .           
     .             template<>
     .               struct __uninitialized_default_n_1<true>
     .               {
     .                 template<typename _ForwardIterator, typename _Size>
     .           	_GLIBCXX20_CONSTEXPR
     .                   static _ForwardIterator
     8 ( 0.00%)          __uninit_default_n(_ForwardIterator __first, _Size __n)
     .                   {
     4 ( 0.00%)  	  if (__n > 0)
     .           	    {
     .           	      typename iterator_traits<_ForwardIterator>::value_type* __val
     1 ( 0.00%)  		= std::__addressof(*__first);
     3 ( 0.00%)  	      std::_Construct(__val);
    31 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Construct<Fusion::RadarData>(Fusion::RadarData*) (1x)
     1 ( 0.00%)  	      ++__first;
     8 ( 0.00%)  	      __first = std::fill_n(__first, __n - 1, *__val);
     .           	    }
     1 ( 0.00%)  	  return __first;
     5 ( 0.00%)  	}
     .               };
     .           
     .             // __uninitialized_default
     .             // Fills [first, last) with value-initialized value_types.
     .             template<typename _ForwardIterator>
     .               _GLIBCXX26_CONSTEXPR
     .               inline void
     .               __uninitialized_default(_ForwardIterator __first,
-- line 907 ----------------------------------------
-- line 917 ----------------------------------------
     .           	__uninit_default(__first, __last);
     .               }
     .           
     .             // __uninitialized_default_n
     .             // Fills [first, first + n) with value-initialized value_types.
     .             template<typename _ForwardIterator, typename _Size>
     .               _GLIBCXX20_CONSTEXPR
     .               inline _ForwardIterator
   990 ( 0.00%)      __uninitialized_default_n(_ForwardIterator __first, _Size __n)
     .               {
     .           #ifdef __cpp_lib_is_constant_evaluated
     .                 if (std::is_constant_evaluated())
     .           	return __uninitialized_default_n_1<false>::
     .           		 __uninit_default_n(__first, __n);
     .           #endif
     .           
     .                 typedef typename iterator_traits<_ForwardIterator>::value_type
     .           	_ValueType;
     .                 // See uninitialized_fill_n for the conditions for using std::fill_n.
   198 ( 0.00%)        constexpr bool __can_fill
     .           	= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
     .           
     .                 return __uninitialized_default_n_1<__is_trivial(_ValueType)
     .           					 && __can_fill>::
   990 ( 0.00%)  	__uninit_default_n(__first, __n);
   169 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::RadarData* std::__uninitialized_default_n_1<true>::__uninit_default_n<Fusion::RadarData*, unsigned long>(Fusion::RadarData*, unsigned long) (1x)
   396 ( 0.00%)      }
     .           
     .           
     .             // __uninitialized_default_a
     .             // Fills [first, last) with value_types constructed by the allocator
     .             // alloc, with no arguments passed to the construct call.
     .             template<typename _ForwardIterator, typename _Allocator>
     .               void
     .               __uninitialized_default_a(_ForwardIterator __first,
-- line 950 ----------------------------------------
-- line 986 ----------------------------------------
     .               }
     .           
     .           #if _GLIBCXX_HOSTED
     .             // __uninitialized_default_n_a specialization for std::allocator,
     .             // which ignores the allocator and value-initializes the elements.
     .             template<typename _ForwardIterator, typename _Size, typename _Tp>
     .               _GLIBCXX20_CONSTEXPR
     .               inline _ForwardIterator
 1,188 ( 0.00%)      __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
     .           				allocator<_Tp>&)
 1,386 ( 0.00%)      { return std::__uninitialized_default_n(__first, __n); }
   182 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::RadarData* std::__uninitialized_default_n<Fusion::RadarData*, unsigned long>(Fusion::RadarData*, unsigned long) (1x)
     .           #endif
     .           
     .             template<bool _TrivialValueType>
     .               struct __uninitialized_default_novalue_1
     .               {
     .                 template<typename _ForwardIterator>
     .           	_GLIBCXX26_CONSTEXPR
     .           	static void
-- line 1004 ----------------------------------------
-- line 1289 ----------------------------------------
     .               struct __is_bitwise_relocatable
     .               : __bool_constant<__is_trivial(_Tp)>
     .               { };
     .           
     .             template <typename _InputIterator, typename _ForwardIterator,
     .           	    typename _Allocator>
     .               _GLIBCXX20_CONSTEXPR
     .               inline _ForwardIterator
 1,379 ( 0.00%)      __relocate_a_1(_InputIterator __first, _InputIterator __last,
     .           		   _ForwardIterator __result, _Allocator& __alloc)
     .               noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
     .           					       std::addressof(*__first),
     .           					       __alloc)))
     .               {
     .                 typedef typename iterator_traits<_InputIterator>::value_type
     .           	_ValueType;
     .                 typedef typename iterator_traits<_ForwardIterator>::value_type
     .           	_ValueType2;
     .                 static_assert(std::is_same<_ValueType, _ValueType2>::value,
     .           	  "relocation is only possible for values of the same type");
   394 ( 0.00%)        _ForwardIterator __cur = __result;
   788 ( 0.00%)        for (; __first != __last; ++__first, (void)++__cur)
     .           	std::__relocate_object_a(std::__addressof(*__cur),
     .           				 std::__addressof(*__first), __alloc);
   197 ( 0.00%)        return __cur;
   394 ( 0.00%)      }
     .           
     .           #if _GLIBCXX_HOSTED
     .             template <typename _Tp, typename _Up>
     .               _GLIBCXX20_CONSTEXPR
     .               inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
11,039 ( 0.01%)      __relocate_a_1(_Tp* __first, _Tp* __last,
     .           		   _Tp* __result,
     .           		   [[__maybe_unused__]] allocator<_Up>& __alloc) noexcept
     .               {
11,036 ( 0.01%)        ptrdiff_t __count = __last - __first;
 3,154 ( 0.00%)        if (__count > 0)
     .           	{
     .           #ifdef __cpp_lib_is_constant_evaluated
     .           	  if (std::is_constant_evaluated())
     .           	    {
     .           	      // Can't use memcpy. Wrap the pointer so that __relocate_a_1
     .           	      // resolves to the non-trivial overload above.
     .           	      __gnu_cxx::__normal_iterator<_Tp*, void> __out(__result);
     .           	      __out = std::__relocate_a_1(__first, __last, __out, __alloc);
     .           	      return __out.base();
     .           	    }
     .           #endif
     .           	  __builtin_memcpy(__result, __first, __count * sizeof(_Tp));
     .           	}
12,613 ( 0.01%)        return __result + __count;
 3,154 ( 0.00%)      }
     .           #endif
     .           
     .             template <typename _InputIterator, typename _ForwardIterator,
     .           	    typename _Allocator>
     .               _GLIBCXX20_CONSTEXPR
     .               inline _ForwardIterator
15,966 ( 0.01%)      __relocate_a(_InputIterator __first, _InputIterator __last,
     .           		 _ForwardIterator __result, _Allocator& __alloc)
     .               noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
     .           				     std::__niter_base(__last),
     .           				     std::__niter_base(__result), __alloc)))
     .               {
 5,322 ( 0.00%)        return std::__relocate_a_1(std::__niter_base(__first),
 3,152 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >* std::__relocate_a_1<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*, std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >&) (197x)
     .           				 std::__niter_base(__last),
     .           				 std::__niter_base(__result), __alloc);
 3,548 ( 0.00%)      }
     .           
     .             /// @endcond
     .           #endif // C++11
     .           
     .             /// @} group memory
     .           
     .           _GLIBCXX_END_NAMESPACE_VERSION
     .           } // namespace
-- line 1364 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/new
--------------------------------------------------------------------------------
Ir               

-- line 200 ----------------------------------------
      .           #else
      .           # define _GLIBCXX_PLACEMENT_CONSTEXPR inline
      .           #endif
      .           
      .           // Default placement versions of operator new.
      .           _GLIBCXX_NODISCARD _GLIBCXX_PLACEMENT_CONSTEXPR
      .           void* operator new(std::size_t, void* __p)
      .             _GLIBCXX_TXN_SAFE _GLIBCXX_USE_NOEXCEPT
116,564 ( 0.05%)  { return __p; }
      .           _GLIBCXX_NODISCARD _GLIBCXX_PLACEMENT_CONSTEXPR
      .           void* operator new[](std::size_t, void* __p)
      .             _GLIBCXX_TXN_SAFE _GLIBCXX_USE_NOEXCEPT
      .           { return __p; }
      .           
      .           #undef _GLIBCXX_PLACEMENT_CONSTEXPR
      .           
      .           // Default placement versions of operator delete.
-- line 216 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/cmath
--------------------------------------------------------------------------------
Ir               

-- line 181 ----------------------------------------
      .               ceil(_Tp __x)
      .               { return __builtin_ceil(__x); }
      .           
      .             using ::cos;
      .           
      .           #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
      .             inline _GLIBCXX_CONSTEXPR float
      .             cos(float __x)
     34 ( 0.00%)    { return __builtin_cosf(__x); }
  1,017 ( 0.00%)  => ???:0x0000000000012dc0 (1x)
     26 ( 0.00%)  => ???:0x000000000007de90 (2x)
      .           
      .             inline _GLIBCXX_CONSTEXPR long double
      .             cos(long double __x)
      .             { return __builtin_cosl(__x); }
      .           #endif
      .           
      .             template<typename _Tp>
      .               inline _GLIBCXX_CONSTEXPR
-- line 197 ----------------------------------------
-- line 404 ----------------------------------------
      .           #endif
      .           #endif
      .           
      .             using ::sin;
      .           
      .           #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
      .             inline _GLIBCXX_CONSTEXPR float
      .             sin(float __x)
     34 ( 0.00%)    { return __builtin_sinf(__x); }
    974 ( 0.00%)  => ???:0x0000000000012dc0 (1x)
     30 ( 0.00%)  => ???:0x0000000000082c90 (2x)
      .           
      .             inline _GLIBCXX_CONSTEXPR long double
      .             sin(long double __x)
      .             { return __builtin_sinl(__x); }
      .           #endif
      .           
      .             template<typename _Tp>
      .               inline _GLIBCXX_CONSTEXPR
-- line 420 ----------------------------------------
-- line 1126 ----------------------------------------
      .                                                         int>::__type
      .               fpclassify(_Tp __x)
      .               { return __x != 0 ? FP_NORMAL : FP_ZERO; }
      .           #endif
      .           
      .           #ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
      .             constexpr bool
      .             isfinite(float __x)
176,175 ( 0.08%)    { return __builtin_isfinite(__x); }
      .           
      .             constexpr bool
      .             isfinite(double __x)
      .             { return __builtin_isfinite(__x); }
      .           
      .             constexpr bool
      .             isfinite(long double __x)
      .             { return __builtin_isfinite(__x); }
-- line 1142 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir               

-- line 97 ----------------------------------------
      .           
      .                 struct _Vector_impl_data
      .                 {
      .           	pointer _M_start;
      .           	pointer _M_finish;
      .           	pointer _M_end_of_storage;
      .           
      .           	_GLIBCXX20_CONSTEXPR
 13,599 ( 0.01%)  	_Vector_impl_data() _GLIBCXX_NOEXCEPT
 27,198 ( 0.01%)  	: _M_start(), _M_finish(), _M_end_of_storage()
 13,599 ( 0.01%)  	{ }
      .           
      .           #if __cplusplus >= 201103L
      .           	_GLIBCXX20_CONSTEXPR
  1,360 ( 0.00%)  	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
  2,720 ( 0.00%)  	: _M_start(__x._M_start), _M_finish(__x._M_finish),
  1,360 ( 0.00%)  	  _M_end_of_storage(__x._M_end_of_storage)
  4,420 ( 0.00%)  	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
      .           #endif
      .           
      .           	_GLIBCXX20_CONSTEXPR
      .           	void
  4,728 ( 0.00%)  	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
      .           	{
  4,728 ( 0.00%)  	  _M_start = __x._M_start;
  4,728 ( 0.00%)  	  _M_finish = __x._M_finish;
  4,728 ( 0.00%)  	  _M_end_of_storage = __x._M_end_of_storage;
  3,546 ( 0.00%)  	}
      .           
      .           	_GLIBCXX20_CONSTEXPR
      .           	void
  3,152 ( 0.00%)  	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
      .           	{
      .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
      .           	  // information used by TBAA.
  1,182 ( 0.00%)  	  _Vector_impl_data __tmp;
  4,728 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_Vector_impl_data() (394x)
  1,970 ( 0.00%)  	  __tmp._M_copy_data(*this);
  7,486 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_M_copy_data(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data const&) (394x)
  1,970 ( 0.00%)  	  _M_copy_data(__x);
  7,486 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_M_copy_data(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data const&) (394x)
  1,970 ( 0.00%)  	  __x._M_copy_data(__tmp);
  7,486 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_M_copy_data(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data const&) (394x)
  2,364 ( 0.00%)  	}
      .                 };
      .           
 38,520 ( 0.02%)        struct _Vector_impl
      .           	: public _Tp_alloc_type, public _Vector_impl_data
      .                 {
      .           	_GLIBCXX20_CONSTEXPR
 15,776 ( 0.01%)  	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
      .           	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
      .           #if __cpp_lib_concepts
      .           	requires is_default_constructible_v<_Tp_alloc_type>
      .           #endif
  5,916 ( 0.00%)  	: _Tp_alloc_type()
  2,364 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_Vector_impl_data() (197x)
  5,916 ( 0.00%)  	{ }
      .           
      .           	_GLIBCXX20_CONSTEXPR
 28,171 ( 0.01%)  	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
  6,501 ( 0.00%)  	: _Tp_alloc_type(__a)
 18,912 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_impl_data::_Vector_impl_data() (1,576x)
  6,501 ( 0.00%)  	{ }
      .           
      .           #if __cplusplus >= 201103L
      .           	// Not defaulted, to enforce noexcept(true) even when
      .           	// !is_nothrow_move_constructible<_Tp_alloc_type>.
      .           	_GLIBCXX20_CONSTEXPR
  2,380 ( 0.00%)  	_Vector_impl(_Vector_impl&& __x) noexcept
  2,040 ( 0.00%)  	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
  9,860 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_Vector_impl_data(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data&&) (340x)
  1,020 ( 0.00%)  	{ }
      .           
      .           	_GLIBCXX20_CONSTEXPR
      .           	_Vector_impl(_Tp_alloc_type&& __a) noexcept
      .           	: _Tp_alloc_type(std::move(__a))
      .           	{ }
      .           
      .           	_GLIBCXX20_CONSTEXPR
      .           	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
-- line 170 ----------------------------------------
-- line 299 ----------------------------------------
      .           #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
      .                 };
      .           
      .               public:
      .                 typedef _Alloc allocator_type;
      .           
      .                 _GLIBCXX20_CONSTEXPR
      .                 _Tp_alloc_type&
 25,851 ( 0.01%)        _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
 25,851 ( 0.01%)        { return this->_M_impl; }
      .           
      .                 _GLIBCXX20_CONSTEXPR
      .                 const _Tp_alloc_type&
 11,241 ( 0.01%)        _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
 11,241 ( 0.01%)        { return this->_M_impl; }
      .           
      .                 _GLIBCXX20_CONSTEXPR
      .                 allocator_type
    985 ( 0.00%)        get_allocator() const _GLIBCXX_NOEXCEPT
  2,758 ( 0.00%)        { return allocator_type(_M_get_Tp_allocator()); }
  1,182 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_get_Tp_allocator() const (197x)
      .           
      .           #if __cplusplus >= 201103L
 19,720 ( 0.01%)        _Vector_base() = default;
 44,128 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_impl::_Vector_impl() (1,576x)
      .           #else
      .                 _Vector_base() { }
      .           #endif
      .           
      .                 _GLIBCXX20_CONSTEXPR
    985 ( 0.00%)        _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
  1,576 ( 0.00%)        : _M_impl(__a) { }
  6,501 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl::_Vector_impl(std::allocator<Fusion::FusionOutput> const&) (197x)
      .           
      .                 // Kept for ABI compatibility.
      .           #if !_GLIBCXX_INLINE_VERSION
      .                 _GLIBCXX20_CONSTEXPR
      .                 _Vector_base(size_t __n)
      .                 : _M_impl()
      .                 { _M_create_storage(__n); }
      .           #endif
      .           
      .                 _GLIBCXX20_CONSTEXPR
 13,790 ( 0.01%)        _Vector_base(size_t __n, const allocator_type& __a)
  9,850 ( 0.00%)        : _M_impl(__a)
 13,002 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl::_Vector_impl(std::allocator<Fusion::FusionOutput> const&) (394x)
 17,730 ( 0.01%)        { _M_create_storage(__n); }
 70,405 ( 0.03%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_create_storage(unsigned long) (394x)
      .           
      .           #if __cplusplus >= 201103L
  4,420 ( 0.00%)        _Vector_base(_Vector_base&&) = default;
 19,040 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl::_Vector_impl(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl&&) (340x)
      .           
      .                 // Kept for ABI compatibility.
      .           # if !_GLIBCXX_INLINE_VERSION
      .                 _GLIBCXX20_CONSTEXPR
      .                 _Vector_base(_Tp_alloc_type&& __a) noexcept
      .                 : _M_impl(std::move(__a)) { }
      .           
      .                 _GLIBCXX20_CONSTEXPR
-- line 352 ----------------------------------------
-- line 365 ----------------------------------------
      .           
      .                 _GLIBCXX20_CONSTEXPR
      .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      .                 { }
      .           #endif
      .           
      .                 _GLIBCXX20_CONSTEXPR
 17,120 ( 0.01%)        ~_Vector_base() _GLIBCXX_NOEXCEPT
      .                 {
 29,960 ( 0.01%)  	_M_deallocate(_M_impl._M_start,
342,279 ( 0.16%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_deallocate(Fusion::PixelData*, unsigned long) (3,152x)
 33,309 ( 0.02%)  		      _M_impl._M_end_of_storage - _M_impl._M_start);
 25,680 ( 0.01%)        }
 59,888 ( 0.03%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_impl::~_Vector_impl() (3,152x)
      .           
      .               public:
      .                 _Vector_impl _M_impl;
      .           
      .                 _GLIBCXX20_CONSTEXPR
      .                 pointer
 18,725 ( 0.01%)        _M_allocate(size_t __n)
      .                 {
      .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 22,470 ( 0.01%)  	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
  7,490 ( 0.00%)        }
      .           
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
 36,324 ( 0.02%)        _M_deallocate(pointer __p, size_t __n)
      .                 {
      .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 12,108 ( 0.01%)  	if (__p)
 21,276 ( 0.01%)  	  _Tr::deallocate(_M_impl, __p, __n);
 18,162 ( 0.01%)        }
      .           
      .               protected:
      .           
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
  9,850 ( 0.00%)        _M_create_storage(size_t __n)
      .                 {
 13,790 ( 0.01%)  	this->_M_impl._M_start = this->_M_allocate(__n);
 60,161 ( 0.03%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_allocate(unsigned long) (394x)
  7,880 ( 0.00%)  	this->_M_impl._M_finish = this->_M_impl._M_start;
 18,518 ( 0.01%)  	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
  5,910 ( 0.00%)        }
      .           
      .           #if __glibcxx_containers_ranges // C++ >= 23
      .                 // Called by insert_range, and indirectly by assign_range, append_range.
      .                 // Initializes new elements in storage at __ptr and updates __ptr to
      .                 // point after the last new element.
      .                 // Provides strong exception safety guarantee.
      .                 // Requires [ptr, ptr+distance(rg)) is a valid range.
      .                 template<ranges::input_range _Rg>
-- line 416 ----------------------------------------
-- line 526 ----------------------------------------
      .                 }
      .           
      .                 static pointer
      .                 _S_do_relocate(pointer, pointer, pointer __result,
      .           		     _Tp_alloc_type&, false_type) noexcept
      .                 { return __result; }
      .           
      .                 static _GLIBCXX20_CONSTEXPR pointer
 12,418 ( 0.01%)        _S_relocate(pointer __first, pointer __last, pointer __result,
      .           		  _Tp_alloc_type& __alloc) noexcept
      .                 {
      .           #if __cpp_if_constexpr
      .           	// All callers have already checked _S_use_relocate() so just do it.
 10,644 ( 0.00%)  	return std::__relocate_a(__first, __last, __result, __alloc);
     41 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::RadarData* std::__relocate_a<Fusion::RadarData*, Fusion::RadarData*, std::allocator<Fusion::RadarData> >(Fusion::RadarData*, Fusion::RadarData*, Fusion::RadarData*, std::allocator<Fusion::RadarData>&) (1x)
      .           #else
      .           	using __do_it = __bool_constant<_S_use_relocate()>;
      .           	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
      .           #endif
  3,548 ( 0.00%)        }
      .           #endif // C++11
      .           
      .               protected:
      .                 using _Base::_M_allocate;
      .                 using _Base::_M_deallocate;
      .                 using _Base::_M_impl;
      .                 using _Base::_M_get_Tp_allocator;
      .           
-- line 552 ----------------------------------------
-- line 553 ----------------------------------------
      .               public:
      .                 // [23.2.4.1] construct/copy/destroy
      .                 // (assign() and get_allocator() are also listed in this section)
      .           
      .                 /**
      .                  *  @brief  Creates a %vector with no elements.
      .                  */
      .           #if __cplusplus >= 201103L
 19,720 ( 0.01%)        vector() = default;
 59,888 ( 0.03%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_Vector_base() (1,576x)
      .           #else
      .                 vector() { }
      .           #endif
      .           
      .                 /**
      .                  *  @brief  Creates a %vector with no elements.
      .                  *  @param  __a  An allocator object.
      .                  */
      .                 explicit
      .                 _GLIBCXX20_CONSTEXPR
    985 ( 0.00%)        vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
  1,576 ( 0.00%)        : _Base(__a) { }
  9,062 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_base(std::allocator<Fusion::FusionOutput> const&) (197x)
      .           
      .           #if __cplusplus >= 201103L
      .                 /**
      .                  *  @brief  Creates a %vector with default constructed elements.
      .                  *  @param  __n  The number of elements to initially create.
      .                  *  @param  __a  An allocator.
      .                  *
      .                  *  This constructor fills the %vector with @a __n default
      .                  *  constructed elements.
      .                  */
      .                 explicit
      .                 _GLIBCXX20_CONSTEXPR
  1,379 ( 0.00%)        vector(size_type __n, const allocator_type& __a = allocator_type())
  2,364 ( 0.00%)        : _Base(_S_check_init_len(__n, __a), __a)
 36,198 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_base(unsigned long, std::allocator<Fusion::FusionOutput> const&) (197x)
 16,548 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_S_check_init_len(unsigned long, std::allocator<Fusion::FusionOutput> const&) (197x)
  1,773 ( 0.00%)        { _M_default_initialize(__n); }
 99,091 ( 0.05%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_default_initialize(unsigned long) (197x)
      .           
      .                 /**
      .                  *  @brief  Creates a %vector with copies of an exemplar element.
      .                  *  @param  __n  The number of elements to initially create.
      .                  *  @param  __value  An element to copy.
      .                  *  @param  __a  An allocator.
      .                  *
      .                  *  This constructor fills the %vector with @a __n copies of @a __value.
-- line 596 ----------------------------------------
-- line 623 ----------------------------------------
      .                  *  All the elements of @a __x are copied, but any unused capacity in
      .                  *  @a __x  will not be copied
      .                  *  (i.e. capacity() == size() in the new %vector).
      .                  *
      .                  *  The newly-created %vector uses a copy of the allocator object used
      .                  *  by @a __x (unless the allocator traits dictate a different object).
      .                  */
      .                 _GLIBCXX20_CONSTEXPR
 19,503 ( 0.01%)        vector(const vector& __x)
      .                 : _Base(__x.size(),
 42,552 ( 0.02%)  	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
 55,483 ( 0.03%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_base(unsigned long, std::allocator<Fusion::FusionOutput> const&) (197x)
  2,955 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::size() const (197x)
  1,182 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_get_Tp_allocator() const (197x)
      .                 {
  3,546 ( 0.00%)  	this->_M_impl._M_finish =
 21,276 ( 0.01%)  	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
 16,745 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::FusionOutput* std::__uninitialized_copy_a<__gnu_cxx::__normal_iterator<Fusion::FusionOutput const*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >, __gnu_cxx::__normal_iterator<Fusion::FusionOutput const*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >, Fusion::FusionOutput*, Fusion::FusionOutput>(__gnu_cxx::__normal_iterator<Fusion::FusionOutput const*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >, __gnu_cxx::__normal_iterator<Fusion::FusionOutput const*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >, Fusion::FusionOutput*, std::allocator<Fusion::FusionOutput>&) (197x)
  3,940 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::end() const (197x)
  3,743 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::begin() const (197x)
  3,546 ( 0.00%)  				      this->_M_impl._M_start,
  7,092 ( 0.00%)  				      _M_get_Tp_allocator());
  1,182 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_get_Tp_allocator() (197x)
 17,730 ( 0.01%)        }
      .           
      .           #if __cplusplus >= 201103L
      .                 /**
      .                  *  @brief  %Vector move constructor.
      .                  *
      .                  *  The newly-created %vector contains the exact contents of the
      .                  *  moved instance.
      .                  *  The contents of the moved instance are a valid, but unspecified
      .                  *  %vector.
      .                  */
  4,420 ( 0.00%)        vector(vector&&) noexcept = default;
 23,460 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_base(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >&&) (340x)
      .           
      .                 /// Copy constructor with alternative allocator
      .                 _GLIBCXX20_CONSTEXPR
      .                 vector(const vector& __x, const __type_identity_t<allocator_type>& __a)
      .                 : _Base(__x.size(), __a)
      .                 {
      .           	this->_M_impl._M_finish =
      .           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
-- line 658 ----------------------------------------
-- line 792 ----------------------------------------
      .           
      .                 /**
      .                  *  The dtor only erases the elements, and note that if the
      .                  *  elements themselves are pointers, the pointed-to memory is
      .                  *  not touched in any way.  Managing the pointer is the user's
      .                  *  responsibility.
      .                  */
      .                 _GLIBCXX20_CONSTEXPR
 17,120 ( 0.01%)        ~vector() _GLIBCXX_NOEXCEPT
      .                 {
 29,960 ( 0.01%)  	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
 12,840 ( 0.01%)  		      _M_get_Tp_allocator());
  1,182 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::_M_get_Tp_allocator() (197x)
      .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
 25,680 ( 0.01%)        }
 29,747 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::~_Vector_base() (197x)
      .           
      .                 /**
      .                  *  @brief  %Vector assignment operator.
      .                  *  @param  __x  A %vector of identical element and allocator types.
      .                  *
      .                  *  All the elements of @a __x are copied, but any unused capacity in
      .                  *  @a __x will not be copied.
      .                  *
-- line 813 ----------------------------------------
-- line 825 ----------------------------------------
      .                  *  The contents of @a __x are moved into this %vector (without copying,
      .                  *  if the allocators permit it).
      .                  *  Afterwards @a __x is a valid, but unspecified %vector.
      .                  *
      .                  *  Whether the allocator is moved depends on the allocator traits.
      .                  */
      .                 _GLIBCXX20_CONSTEXPR
      .                 vector&
    985 ( 0.00%)        operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      .                 {
    591 ( 0.00%)  	constexpr bool __move_storage =
      .           	  _Alloc_traits::_S_propagate_on_move_assign()
      .           	  || _Alloc_traits::_S_always_equal();
    788 ( 0.00%)  	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 89,241 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_move_assign(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >&&, std::integral_constant<bool, true>) (197x)
    197 ( 0.00%)  	return *this;
    394 ( 0.00%)        }
      .           
      .                 /**
      .                  *  @brief  %Vector list assignment operator.
      .                  *  @param  __l  An initializer_list.
      .                  *
      .                  *  This function fills a %vector with copies of the elements in the
      .                  *  initializer list @a __l.
      .                  *
-- line 848 ----------------------------------------
-- line 990 ----------------------------------------
      .                 // iterators
      .                 /**
      .                  *  Returns a read/write iterator that points to the first
      .                  *  element in the %vector.  Iteration is done in ordinary
      .                  *  element order.
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 iterator
  2,751 ( 0.00%)        begin() _GLIBCXX_NOEXCEPT
  3,144 ( 0.00%)        { return iterator(this->_M_impl._M_start); }
      .           
      .                 /**
      .                  *  Returns a read-only (constant) iterator that points to the
      .                  *  first element in the %vector.  Iteration is done in ordinary
      .                  *  element order.
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 const_iterator
 26,201 ( 0.01%)        begin() const _GLIBCXX_NOEXCEPT
 29,944 ( 0.01%)        { return const_iterator(this->_M_impl._M_start); }
      .           
      .                 /**
      .                  *  Returns a read/write iterator that points one past the last
      .                  *  element in the %vector.  Iteration is done in ordinary
      .                  *  element order.
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 iterator
  2,751 ( 0.00%)        end() _GLIBCXX_NOEXCEPT
  3,537 ( 0.00%)        { return iterator(this->_M_impl._M_finish); }
      .           
      .                 /**
      .                  *  Returns a read-only (constant) iterator that points one past
      .                  *  the last element in the %vector.  Iteration is done in
      .                  *  ordinary element order.
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 const_iterator
 26,201 ( 0.01%)        end() const _GLIBCXX_NOEXCEPT
 33,687 ( 0.02%)        { return const_iterator(this->_M_impl._M_finish); }
      .           
      .                 /**
      .                  *  Returns a read/write reverse iterator that points to the
      .                  *  last element in the %vector.  Iteration is done in reverse
      .                  *  element order.
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 reverse_iterator
-- line 1037 ----------------------------------------
-- line 1109 ----------------------------------------
      .                 crend() const noexcept
      .                 { return const_reverse_iterator(begin()); }
      .           #endif
      .           
      .                 // [23.2.4.2] capacity
      .                 /**  Returns the number of elements in the %vector.  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 size_type
 15,993 ( 0.01%)        size() const _GLIBCXX_NOEXCEPT
      .                 {
 45,997 ( 0.02%)  	ptrdiff_t __dif = this->_M_impl._M_finish - this->_M_impl._M_start;
  5,331 ( 0.00%)  	if (__dif < 0)
      .           	   __builtin_unreachable ();
  5,331 ( 0.00%)  	return size_type(__dif);
 10,662 ( 0.00%)        }
      .           
      .                 /**  Returns the size() of the largest possible %vector.  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 size_type
  7,108 ( 0.00%)        max_size() const _GLIBCXX_NOEXCEPT
 12,439 ( 0.01%)        { return _S_max_size(_M_get_Tp_allocator()); }
    172 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_S_max_size(std::allocator<Fusion::RadarData> const&) (4x)
     24 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_get_Tp_allocator() const (4x)
      .           
      .           #if __cplusplus >= 201103L
      .                 /**
      .                  *  @brief  Resizes the %vector to the specified number of elements.
      .                  *  @param  __new_size  Number of elements the %vector should contain.
      .                  *
      .                  *  This function will %resize the %vector to the specified
      .                  *  number of elements.  If the number is smaller than the
      .                  *  %vector's current size the %vector is truncated, otherwise
      .                  *  default constructed elements are appended.
      .                  */
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
      5 ( 0.00%)        resize(size_type __new_size)
      .                 {
      7 ( 0.00%)  	if (__new_size > size())
     15 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (1x)
      9 ( 0.00%)  	  _M_default_append(__new_size - size());
  1,051 ( 0.00%)  => /usr/include/c++/15.1.1/bits/vector.tcc:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_default_append(unsigned long) (1x)
     15 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (1x)
      .           	else if (__new_size < size())
      .           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
      4 ( 0.00%)        }
      .           
      .                 /**
      .                  *  @brief  Resizes the %vector to the specified number of elements.
      .                  *  @param  __new_size  Number of elements the %vector should contain.
      .                  *  @param  __x  Data with which new elements should be populated.
      .                  *
      .                  *  This function will %resize the %vector to the specified
      .                  *  number of elements.  If the number is smaller than the
-- line 1157 ----------------------------------------
-- line 1200 ----------------------------------------
      .           #endif
      .           
      .                 /**
      .                  *  Returns the total number of elements that the %vector can
      .                  *  hold before needing to allocate more memory.
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 size_type
  5,910 ( 0.00%)        capacity() const _GLIBCXX_NOEXCEPT
      .                 {
 11,623 ( 0.01%)  	ptrdiff_t __dif = this->_M_impl._M_end_of_storage
  5,910 ( 0.00%)  			  - this->_M_impl._M_start;
  1,970 ( 0.00%)  	if (__dif < 0)
      .           	   __builtin_unreachable ();
  1,970 ( 0.00%)  	return size_type(__dif);
  3,940 ( 0.00%)        }
      .           
      .                 /**
      .                  *  Returns true if the %vector is empty.  (Thus begin() would
      .                  *  equal end().)
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 bool
      .                 empty() const _GLIBCXX_NOEXCEPT
-- line 1223 ----------------------------------------
-- line 1253 ----------------------------------------
      .                  *
      .                  *  This operator allows for easy, array-style, data access.
      .                  *  Note that data access with this operator is unchecked and
      .                  *  out_of_range lookups are not defined. (For checked lookups
      .                  *  see at().)
      .                  */
      .                 _GLIBCXX_NODISCARD _GLIBCXX20_CONSTEXPR
      .                 reference
  5,940 ( 0.00%)        operator[](size_type __n) _GLIBCXX_NOEXCEPT
      .                 {
 11,880 ( 0.01%)  	__glibcxx_requires_subscript(__n);
 17,820 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (1,188x)
  5,940 ( 0.00%)  	return *(this->_M_impl._M_start + __n);
  2,376 ( 0.00%)        }
      .           
      .                 /**
      .                  *  @brief  Subscript access to the data contained in the %vector.
      .                  *  @param __n The index of the element for which data should be
      .                  *  accessed.
      .                  *  @return  Read-only (constant) reference to data.
      .                  *
      .                  *  This operator allows for easy, array-style, data access.
-- line 1273 ----------------------------------------
-- line 1408 ----------------------------------------
      .                  *  This is a typical stack operation.  The function creates an
      .                  *  element at the end of the %vector and assigns the given data
      .                  *  to it.  Due to the nature of a %vector this operation can be
      .                  *  done in constant time if the %vector has preallocated space
      .                  *  available.
      .                  */
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
 84,912 ( 0.04%)        push_back(const value_type& __x)
      .                 {
 80,184 ( 0.04%)  	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
      .           	  {
      .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
120,276 ( 0.06%)  	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      .           				     __x);
 66,820 ( 0.03%)  	    ++this->_M_impl._M_finish;
      .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
      .           	  }
      .           	else
      .           	  _M_realloc_append(__x);
 73,124 ( 0.03%)        }
      .           
      .           #if __cplusplus >= 201103L
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
      .                 push_back(value_type&& __x)
      .                 { emplace_back(std::move(__x)); }
      .           
      .                 template<typename... _Args>
-- line 1436 ----------------------------------------
-- line 1867 ----------------------------------------
      .                 // RAII guard for allocated storage.
      .                 struct _Guard_alloc
      .                 {
      .           	pointer _M_storage;	    // Storage to deallocate
      .           	size_type _M_len;
      .           	_Base& _M_vect;
      .           
      .           	_GLIBCXX20_CONSTEXPR
     12 ( 0.00%)  	_Guard_alloc(pointer __s, size_type __l, _Base& __vect)
     18 ( 0.00%)  	: _M_storage(__s), _M_len(__l), _M_vect(__vect)
      6 ( 0.00%)  	{ }
      .           
      .           	_GLIBCXX20_CONSTEXPR
      8 ( 0.00%)  	~_Guard_alloc()
      .           	{
      8 ( 0.00%)  	  if (_M_storage)
      .           	    _M_vect._M_deallocate(_M_storage, _M_len);
      6 ( 0.00%)  	}
      .           
      .           	_GLIBCXX20_CONSTEXPR
      .           	pointer
      3 ( 0.00%)  	_M_release()
      .           	{
      3 ( 0.00%)  	  pointer __res = _M_storage;
      2 ( 0.00%)  	  _M_storage = pointer();
      1 ( 0.00%)  	  return __res;
      2 ( 0.00%)  	}
      .           
      .                 private:
      .           	_Guard_alloc(const _Guard_alloc&);
      .                 };
      .           
      .               protected:
      .                 /**
      .                  *  Memory expansion handler.  Uses the member allocation function to
      .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
      .                  */
      .                 template<typename _ForwardIterator>
      .           	_GLIBCXX20_CONSTEXPR
      .           	pointer
     11 ( 0.00%)  	_M_allocate_and_copy(size_type __n,
      .           			     _ForwardIterator __first, _ForwardIterator __last)
      .           	{
     12 ( 0.00%)  	  _Guard_alloc __guard(this->_M_allocate(__n), __n, *this);
    103 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_allocate(unsigned long) (1x)
     18 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_Guard_alloc::_Guard_alloc(Fusion::RadarData*, unsigned long, std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >&) (1x)
      .           	  std::__uninitialized_copy_a
      9 ( 0.00%)  	    (__first, __last, __guard._M_storage, _M_get_Tp_allocator());
     85 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::RadarData* std::__uninitialized_copy_a<__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, Fusion::RadarData>(__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, std::allocator<Fusion::RadarData>&) (1x)
      6 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_get_Tp_allocator() (1x)
      6 ( 0.00%)  	  return __guard._M_release();
     11 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_Guard_alloc::_M_release() (1x)
      9 ( 0.00%)  	}
     11 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_Guard_alloc::~_Guard_alloc() (1x)
      .           
      .           
      .                 // Internal constructor functions follow.
      .           
      .                 // Called by the range constructor to implement [23.1.1]/9
      .           
      .           #if __cplusplus < 201103L
      .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 1922 ----------------------------------------
-- line 1999 ----------------------------------------
      .           	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
      .           					_M_get_Tp_allocator());
      .                 }
      .           
      .           #if __cplusplus >= 201103L
      .                 // Called by the vector(n) constructor.
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
    985 ( 0.00%)        _M_default_initialize(size_type __n)
      .                 {
    394 ( 0.00%)  	this->_M_impl._M_finish =
  1,182 ( 0.00%)  	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
 93,969 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::FusionOutput* std::__uninitialized_default_n_a<Fusion::FusionOutput*, unsigned long, Fusion::FusionOutput>(Fusion::FusionOutput*, unsigned long, std::allocator<Fusion::FusionOutput>&) (197x)
    788 ( 0.00%)  					   _M_get_Tp_allocator());
  1,182 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_get_Tp_allocator() (197x)
    591 ( 0.00%)        }
      .           #endif
      .           
      .                 // Internal assign functions follow.  The *_aux functions do the actual
      .                 // assignment work for the range versions.
      .           
      .                 // Called by the range assign to implement [23.1.1]/9
      .           
      .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
-- line 2020 ----------------------------------------
-- line 2188 ----------------------------------------
      .                 iterator
      .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
      .                 { return _M_insert_rval(__position, std::move(__v)); }
      .           #endif
      .           
      .                 // Called by _M_fill_insert, _M_insert_aux etc.
      .                 _GLIBCXX20_CONSTEXPR
      .                 size_type
     10 ( 0.00%)        _M_check_len(size_type __n, const char* __s) const
      .                 {
     14 ( 0.00%)  	if (max_size() - size() < __n)
     60 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::max_size() const (1x)
     15 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (1x)
      .           	  __throw_length_error(__N(__s));
      .           
     16 ( 0.00%)  	const size_type __len = size() + (std::max)(size(), __n);
     30 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (2x)
     14 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_algobase.h:unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&) (1x)
     11 ( 0.00%)  	return (__len < size() || __len > max_size()) ? max_size() : __len;
     60 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::max_size() const (1x)
     15 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (1x)
      6 ( 0.00%)        }
      .           
      .                 // Called by constructors to check initial size.
      .                 static _GLIBCXX20_CONSTEXPR size_type
  2,955 ( 0.00%)        _S_check_init_len(size_type __n, const allocator_type& __a)
      .                 {
  1,379 ( 0.00%)  	if (__n > _S_max_size(_Tp_alloc_type(__a)))
  8,471 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_S_max_size(std::allocator<Fusion::FusionOutput> const&) (197x)
      .           	  __throw_length_error(
      .           	      __N("cannot create std::vector larger than max_size()"));
    197 ( 0.00%)  	return __n;
  1,182 ( 0.00%)        }
      .           
      .                 static _GLIBCXX20_CONSTEXPR size_type
 13,818 ( 0.01%)        _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
      .                 {
      .           	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
      .           	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
      .           	// (even if std::allocator_traits::max_size says we can).
 15,792 ( 0.01%)  	const size_t __diffmax
      .           	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
  1,974 ( 0.00%)  	const size_t __allocmax = _Alloc_traits::max_size(__a);
 11,844 ( 0.01%)  	return (std::min)(__diffmax, __allocmax);
     52 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_algobase.h:unsigned long const& std::min<unsigned long>(unsigned long const&, unsigned long const&) (4x)
  9,870 ( 0.00%)        }
      .           
      .                 // Internal erase functions follow.
      .           
      .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
      .                 // _M_assign_aux.
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
      .                 _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
-- line 2233 ----------------------------------------
-- line 2251 ----------------------------------------
      .           
      .           #if __cplusplus >= 201103L
      .               private:
      .                 // Constant-time move assignment when source object's memory can be
      .                 // moved, either because the source's allocator will move too
      .                 // or because the allocators are equal.
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
  1,773 ( 0.00%)        _M_move_assign(vector&& __x, true_type) noexcept
      .                 {
  1,970 ( 0.00%)  	vector __tmp(get_allocator());
 11,623 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::vector(std::allocator<Fusion::FusionOutput> const&) (197x)
  5,319 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::get_allocator() const (197x)
    985 ( 0.00%)  	this->_M_impl._M_swap_data(__x._M_impl);
 19,897 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_M_swap_data(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data&) (197x)
    985 ( 0.00%)  	__tmp._M_impl._M_swap_data(__x._M_impl);
 19,897 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data::_M_swap_data(std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_Vector_impl_data&) (197x)
  2,167 ( 0.00%)  	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
  2,364 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::_M_get_Tp_allocator() (394x)
  1,773 ( 0.00%)        }
 18,321 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::~vector() (197x)
      .           
      .                 // Do move assignment when it might not be possible to move source
      .                 // object's memory, resulting in a linear-time operation.
      .                 _GLIBCXX20_CONSTEXPR
      .                 void
      .                 _M_move_assign(vector&& __x, false_type)
      .                 {
      .           	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
-- line 2273 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/new_allocator.h
--------------------------------------------------------------------------------
Ir               

-- line 80 ----------------------------------------
      .           #if __cplusplus >= 201103L
      .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .                 // 2103. propagate_on_container_move_assignment
      .                 typedef std::true_type propagate_on_container_move_assignment;
      .           #endif
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX20_CONSTEXPR
  2,169 ( 0.00%)        __new_allocator() _GLIBCXX_USE_NOEXCEPT { }
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX20_CONSTEXPR
  4,674 ( 0.00%)        __new_allocator(const __new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
      .           
      .                 template<typename _Tp1>
      .           	__attribute__((__always_inline__))
      .           	_GLIBCXX20_CONSTEXPR
      .           	__new_allocator(const __new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
      .           
      .           #if __cplusplus >= 201103L
      .                 __new_allocator& operator=(const __new_allocator&) = default;
      .           #endif
      .           
      .           #if __cplusplus <= 201703L
 39,864 ( 0.02%)        ~__new_allocator() _GLIBCXX_USE_NOEXCEPT { }
      .           
      .                 pointer
      .                 address(reference __x) const _GLIBCXX_NOEXCEPT
      .                 { return std::__addressof(__x); }
      .           
      .                 const_pointer
      .                 address(const_reference __x) const _GLIBCXX_NOEXCEPT
      .                 { return std::__addressof(__x); }
-- line 112 ----------------------------------------
-- line 118 ----------------------------------------
      .           #else
      .           # define _GLIBCXX_OPERATOR_NEW ::operator new
      .           # define _GLIBCXX_OPERATOR_DELETE ::operator delete
      .           #endif
      .           
      .                 // NB: __n is permitted to be 0.  The C++ standard says nothing
      .                 // about what the return value is when __n == 0.
      .                 _GLIBCXX_NODISCARD _Tp*
 29,960 ( 0.01%)        allocate(size_type __n, const void* = static_cast<const void*>(0))
      .                 {
      .           #if __cplusplus >= 201103L
      .           	// _GLIBCXX_RESOLVE_LIB_DEFECTS
      .           	// 3308. std::allocator<void>().allocate(n)
      .           	static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
      .           #endif
      .           
 26,215 ( 0.01%)  	if (__builtin_expect(__n > this->_M_max_size(), false))
      .           	  {
      .           	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
      .           	    // 3190. allocator::allocate sometimes returns too little storage
      .           	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
      .           	      std::__throw_bad_array_new_length();
      .           	    std::__throw_bad_alloc();
      .           	  }
      .           
-- line 142 ----------------------------------------
-- line 143 ----------------------------------------
      .           #if __cpp_aligned_new && __cplusplus >= 201103L
      .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
      .           	  {
      .           	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
      .           	    return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp),
      .           							   __al));
      .           	  }
      .           #endif
 32,517 ( 0.02%)  	return static_cast<_Tp*>(_GLIBCXX_OPERATOR_NEW(__n * sizeof(_Tp)));
280,404 ( 0.13%)  => /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (3,152x)
  7,490 ( 0.00%)        }
      .           
      .                 // __p is not permitted to be a null pointer.
      .                 void
 21,276 ( 0.01%)        deallocate(_Tp* __p, size_type __n __attribute__ ((__unused__)))
      .                 {
      .           #if __cpp_sized_deallocation
      .           # define _GLIBCXX_SIZED_DEALLOC(p, n) (p), (n) * sizeof(_Tp)
      .           #else
      .           # define _GLIBCXX_SIZED_DEALLOC(p, n) (p)
      .           #endif
      .           
      .           #if __cpp_aligned_new && __cplusplus >= 201103L
      .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
      .           	  {
      .           	    _GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n),
      .           				     std::align_val_t(alignof(_Tp)));
      .           	    return;
      .           	  }
      .           #endif
 38,419 ( 0.02%)  	_GLIBCXX_OPERATOR_DELETE(_GLIBCXX_SIZED_DEALLOC(__p, __n));
205,753 ( 0.10%)  => /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/del_ops.cc:operator delete(void*, unsigned long) (3,151x)
    986 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
  7,092 ( 0.00%)        }
      .           
      .           #undef _GLIBCXX_SIZED_DEALLOC
      .           #undef _GLIBCXX_OPERATOR_DELETE
      .           #undef _GLIBCXX_OPERATOR_NEW
      .           
      .           #if __cplusplus <= 201703L
      .                 __attribute__((__always_inline__))
      .                 size_type
      .                 max_size() const _GLIBCXX_USE_NOEXCEPT
  1,974 ( 0.00%)        { return _M_max_size(); }
      .           
      .           #if __cplusplus >= 201103L
      .                 template<typename _Up, typename... _Args>
      .           	__attribute__((__always_inline__))
      .           	void
      .           	construct(_Up* __p, _Args&&... __args)
      .           	noexcept(__is_nothrow_new_constructible<_Up, _Args...>)
188,672 ( 0.09%)  	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 82,516 ( 0.04%)  => /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) (11,788x)
      .           
      .                 template<typename _Up>
      .           	__attribute__((__always_inline__))
      .           	void
      .           	destroy(_Up* __p)
      .           	noexcept(std::is_nothrow_destructible<_Up>::value)
      .           	{ __p->~_Up(); }
      .           #else
-- line 199 ----------------------------------------
-- line 225 ----------------------------------------
      .           #endif
      .           
      .               private:
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX_CONSTEXPR size_type
      .                 _M_max_size() const _GLIBCXX_USE_NOEXCEPT
      .                 {
      .           #if __PTRDIFF_MAX__ < __SIZE_MAX__
  5,719 ( 0.00%)  	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
      .           #else
      .           	return std::size_t(-1) / sizeof(_Tp);
      .           #endif
      .                 }
      .               };
      .           
      .           _GLIBCXX_END_NAMESPACE_VERSION
      .           } // namespace
-- line 241 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/stl_construct.h
--------------------------------------------------------------------------------
Ir              

-- line 115 ----------------------------------------
     .             /**
     .              * Constructs an object in existing memory by invoking an allocated
     .              * object's constructor with an initializer.
     .              */
     .           #if __cplusplus >= 201103L
     .             template<typename _Tp, typename... _Args>
     .               _GLIBCXX20_CONSTEXPR
     .               inline void
 7,097 ( 0.00%)      _Construct(_Tp* __p, _Args&&... __args)
     .               {
     .           #if __cpp_constexpr_dynamic_alloc // >= C++20
     .                 if (std::__is_constant_evaluated())
     .           	{
     .           	  // Allow std::_Construct to be used in constant expressions.
     .           	  std::construct_at(__p, std::forward<_Args>(__args)...);
     .           	  return;
     .           	}
     .           #endif
11,835 ( 0.01%)        ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...);
     7 ( 0.00%)  => /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) (1x)
 7,096 ( 0.00%)      }
     .           #else
     .             template<typename _T1, typename _T2>
     .               inline void
     .               _Construct(_T1* __p, const _T2& __value)
     .               {
     .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
     .                 // 402. wrong new expression in [some_]allocator::construct
     .                 ::new(static_cast<void*>(__p)) _T1(__value);
-- line 142 ----------------------------------------
-- line 153 ----------------------------------------
     .               _GLIBCXX20_CONSTEXPR void
     .               _Destroy(_ForwardIterator __first, _ForwardIterator __last);
     .           
     .             /**
     .              * Destroy the object pointed to by a pointer type.
     .              */
     .             template<typename _Tp>
     .               _GLIBCXX14_CONSTEXPR inline void
 7,632 ( 0.00%)      _Destroy(_Tp* __pointer)
     .               {
     .           #if __cpp_constexpr_dynamic_alloc // >= C++20
     .                 std::destroy_at(__pointer);
     .           #else
 5,724 ( 0.00%)        __pointer->~_Tp();
303,529 ( 0.14%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::~vector() (1,576x)
     .           #endif
 5,724 ( 0.00%)      }
     .           
     .           #pragma GCC diagnostic push
     .           #pragma GCC diagnostic ignored "-Wc++17-extensions" // for if-constexpr
     .           
     .           #if __cplusplus < 201103L
     .             template<bool>
     .               struct _Destroy_aux
     .               {
-- line 176 ----------------------------------------
-- line 194 ----------------------------------------
     .           
     .             /**
     .              * Destroy a range of objects.  If the value_type of the object has
     .              * a trivial destructor, the compiler should optimize all of this
     .              * away, otherwise the objects' destructors must be invoked.
     .              */
     .             template<typename _ForwardIterator>
     .               _GLIBCXX20_CONSTEXPR inline void
18,928 ( 0.01%)      _Destroy(_ForwardIterator __first, _ForwardIterator __last)
     .               {
     .                 typedef typename iterator_traits<_ForwardIterator>::value_type
     .                                  _Value_type;
     .           #if __cplusplus >= 201103L
     .                 // A deleted destructor is trivial, this ensures we reject such types:
     .                 static_assert(is_destructible<_Value_type>::value,
     .           		    "value type is destructible");
     .                 if constexpr (!__has_trivial_destructor(_Value_type))
12,264 ( 0.01%)  	for (; __first != __last; ++__first)
 3,816 ( 0.00%)  	  std::_Destroy(std::__addressof(*__first));
34,196 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Destroy<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*) (332x)
     .           #if __cpp_constexpr_dynamic_alloc // >= C++20
     .                 else if (std::__is_constant_evaluated())
     .           	for (; __first != __last; ++__first)
     .           	  std::destroy_at(std::__addressof(*__first));
     .           #endif
     .           #else
     .                 std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
     .           	__destroy(__first, __last);
     .           #endif
14,247 ( 0.01%)      }
     .           
     .           #if __cplusplus < 201103L
     .             template<bool>
     .               struct _Destroy_n_aux
     .               {
     .                 template<typename _ForwardIterator, typename _Size>
     .           	static _GLIBCXX20_CONSTEXPR _ForwardIterator
     .           	__destroy_n(_ForwardIterator __first, _Size __count)
-- line 230 ----------------------------------------
-- line 279 ----------------------------------------
     .           	__destroy_n(__first, __count);
     .           #endif
     .               }
     .           #pragma GCC diagnostic pop
     .           
     .           #if __glibcxx_raw_memory_algorithms // >= C++17
     .             template <typename _ForwardIterator>
     .               _GLIBCXX20_CONSTEXPR inline void
    35 ( 0.00%)      destroy(_ForwardIterator __first, _ForwardIterator __last)
     .               {
    35 ( 0.00%)        std::_Destroy(__first, __last);
37,275 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Destroy<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*>(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*) (7x)
    21 ( 0.00%)      }
     .           
     .             template <typename _ForwardIterator, typename _Size>
     .               _GLIBCXX20_CONSTEXPR inline _ForwardIterator
     .               destroy_n(_ForwardIterator __first, _Size __count)
     .               {
     .                 return std::_Destroy_n(__first, __count);
     .               }
     .           #endif // C++17
-- line 298 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qjsonarray.h
--------------------------------------------------------------------------------
Ir               

-- line 75 ----------------------------------------
      .               public:
      .                   typedef std::random_access_iterator_tag  iterator_category;
      .                   typedef qsizetype difference_type;
      .                   typedef QJsonValue value_type;
      .                   typedef QJsonValueRef reference;
      .                   typedef QJsonValueRef *pointer;
      .           
      .                   inline iterator() : item(static_cast<QJsonArray *>(nullptr), 0) { }
 59,100 ( 0.03%)          explicit inline iterator(QJsonArray *array, qsizetype index) : item(array, index) { }
153,660 ( 0.07%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::QJsonValueRef(QJsonArray*, long long) (3,940x)
      .           
      .                   constexpr iterator(const iterator &other) = default;
      .                   iterator &operator=(const iterator &other)
      .                   {
      .                       item.rebind(other.item);
      .                       return *this;
      .                   }
      .           
119,520 ( 0.06%)          inline QJsonValueRef operator*() const { return item; }
      .                   inline const QJsonValueConstRef *operator->() const { return &item; }
      .                   inline QJsonValueRef *operator->() { return &item; }
      .                   inline QJsonValueRef operator[](qsizetype j) const { return *(*this + j); }
      .           
      .           #if QT_CORE_REMOVED_SINCE(6, 8)
      .                   inline bool operator==(const iterator &o) const
      .                   { return item.d == o.item.d && item.index == o.item.index; }
      .                   inline bool operator!=(const iterator &o) const { return !operator==(o); }
-- line 100 ----------------------------------------
-- line 109 ----------------------------------------
      .                   inline bool operator!=(const const_iterator &o) const { return !operator==(o); }
      .                   inline bool operator<(const const_iterator &other) const
      .                   { Q_ASSERT(item.d == other.item.d); return item.index < other.item.index; }
      .                   inline bool operator<=(const const_iterator &other) const
      .                   { Q_ASSERT(item.d == other.item.d); return item.index <= other.item.index; }
      .                   inline bool operator>(const const_iterator &other) const { return !operator<=(other); }
      .                   inline bool operator>=(const const_iterator &other) const { return !operator<(other); }
      .           #endif
268,920 ( 0.13%)          inline iterator &operator++() { ++item.index; return *this; }
      .                   inline iterator operator++(int) { iterator n = *this; ++item.index; return n; }
      .                   inline iterator &operator--() { item.index--; return *this; }
      .                   inline iterator operator--(int) { iterator n = *this; item.index--; return n; }
      .                   inline iterator &operator+=(qsizetype j) { item.index += quint64(j); return *this; }
      .                   inline iterator &operator-=(qsizetype j) { item.index -= quint64(j); return *this; }
      .                   inline iterator operator+(qsizetype j) const { iterator r = *this; return r += j; }
      .                   inline iterator operator-(qsizetype j) const { return operator+(-j); }
      .                   inline qsizetype operator-(iterator j) const { return item.index - j.item.index; }
      .           
      .               private:
      .                   // Helper functions
 67,640 ( 0.03%)          static bool comparesEqual_helper(const iterator &lhs, const iterator &rhs) noexcept
      .                   {
272,530 ( 0.13%)              return lhs.item.d == rhs.item.d && lhs.item.index == rhs.item.index;
 33,820 ( 0.02%)          }
      .           
      .                   static bool comparesEqual_helper(const iterator &lhs, const const_iterator &rhs) noexcept
      .                   {
      .                       return lhs.item.d == rhs.item.d && lhs.item.index == rhs.item.index;
      .                   }
      .           
      .                   static Qt::strong_ordering compareThreeWay_helper(const iterator &lhs,
      .                                                                     const iterator &rhs)
-- line 140 ----------------------------------------
-- line 146 ----------------------------------------
      .                   static Qt::strong_ordering compareThreeWay_helper(const iterator &lhs,
      .                                                                     const const_iterator &rhs)
      .                   {
      .                       Q_ASSERT(lhs.item.d == rhs.item.d);
      .                       return Qt::compareThreeWay(lhs.item.index, rhs.item.index);
      .                   }
      .           
      .                   // Compare friends
 84,550 ( 0.04%)          friend bool comparesEqual(const iterator &lhs, const iterator &rhs) noexcept
      .                   {
 84,550 ( 0.04%)              return comparesEqual_helper(lhs, rhs);
373,990 ( 0.17%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::comparesEqual_helper(QJsonArray::iterator const&, QJsonArray::iterator const&) (16,910x)
 33,820 ( 0.02%)          }
      .                   friend Qt::strong_ordering compareThreeWay(const iterator &lhs,
      .                                                              const iterator &rhs)
      .                   {
      .                       return compareThreeWay_helper(lhs, rhs);
      .                   }
219,830 ( 0.10%)          Q_DECLARE_STRONGLY_ORDERED_NON_NOEXCEPT(iterator)
576,910 ( 0.27%)  => /usr/include/qt6/QtCore/qjsonarray.h:comparesEqual(QJsonArray::iterator const&, QJsonArray::iterator const&) (16,910x)
      .                   friend bool comparesEqual(const iterator &lhs, const const_iterator &rhs) noexcept
      .                   {
      .                       return comparesEqual_helper(lhs, rhs);
      .                   }
      .                   friend Qt::strong_ordering compareThreeWay(const iterator &lhs,
      .                                                              const const_iterator &rhs)
      .                   {
      .                       return compareThreeWay_helper(lhs, rhs);
-- line 171 ----------------------------------------
-- line 248 ----------------------------------------
      .                   }
      .                   Q_DECLARE_STRONGLY_ORDERED_NON_NOEXCEPT(const_iterator)
      .                   QJsonValueConstRef item;
      .                   friend class QJsonArray;
      .               };
      .               friend class const_iterator;
      .           
      .               // stl style
 49,254 ( 0.02%)      inline iterator begin() { detach(); return iterator(this, 0); }
1,066,032 ( 0.50%)  => ???:QJsonArray::detach(long long) (1,969x)
106,380 ( 0.05%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::iterator(QJsonArray*, long long) (1,970x)
  1,688 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
      .               inline const_iterator begin() const { return const_iterator(this, 0); }
      .               inline const_iterator constBegin() const { return const_iterator(this, 0); }
      .               inline const_iterator cbegin() const { return const_iterator(this, 0); }
 57,130 ( 0.03%)      inline iterator end() { detach(); return iterator(this, size()); }
106,380 ( 0.05%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::iterator(QJsonArray*, long long) (1,970x)
 45,310 ( 0.02%)  => ???:QJsonArray::detach(long long) (1,970x)
 13,790 ( 0.01%)  => ???:QJsonArray::size() const (1,970x)
      .               inline const_iterator end() const { return const_iterator(this, size()); }
      .               inline const_iterator constEnd() const { return const_iterator(this, size()); }
      .               inline const_iterator cend() const { return const_iterator(this, size()); }
      .               iterator insert(iterator before, const QJsonValue &value)
      .               { insert(before.item.index, value); return before; }
      .               iterator erase(iterator it)
      .               { removeAt(it.item.index); return it; }
      .           
-- line 268 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: ../../FusionUtils/pixel2world.cpp
--------------------------------------------------------------------------------
Ir               

      .           #include "pixel2world.h"
      .           
      6 ( 0.00%)  PixelToWorld::CameraPose::CameraPose(float pos[3], float rot[3])
      .           {
      4 ( 0.00%)      position[0] = pos[0];
      4 ( 0.00%)      position[1] = pos[1];
      4 ( 0.00%)      position[2] = pos[2];
      4 ( 0.00%)      rotation[0] = rot[0];
      4 ( 0.00%)      rotation[1] = rot[1];
      4 ( 0.00%)      rotation[2] = rot[2];
      3 ( 0.00%)      updateRotationMatrix();
  2,287 ( 0.00%)  => ../../FusionUtils/pixel2world.cpp:PixelToWorld::CameraPose::updateRotationMatrix() (1x)
      3 ( 0.00%)  }
      .           
      .           void PixelToWorld::CameraPose::updateRotationMatrix()
      8 ( 0.00%)  {
     31 ( 0.00%)      rotationMatrix = PixelToWorld::CameraPose::eulerToRotationMatrix(
  2,241 ( 0.00%)  => ../../FusionUtils/pixel2world.cpp:PixelToWorld::CameraPose::eulerToRotationMatrix(float, float, float) (1x)
      .                   rotation[0], rotation[1], rotation[2]);
      7 ( 0.00%)  }
      .           
      3 ( 0.00%)  PixelToWorld::PixelToWorld()
      4 ( 0.00%)      : m_intrinsicsSet(false), m_poseSet(false)
      .           {
      3 ( 0.00%)  }
      .           
      .           void PixelToWorld::setCameraIntrinsics(const CameraIntrinsics& intrinsics)
      4 ( 0.00%)  {
     10 ( 0.00%)      m_intrinsics = intrinsics;
      2 ( 0.00%)      m_intrinsicsSet = true;
      3 ( 0.00%)  }
      .           
      .           void PixelToWorld::setCameraPose(const CameraPose& pose)
      5 ( 0.00%)  {
     24 ( 0.00%)      m_pose = pose;
      2 ( 0.00%)      m_poseSet = true;
      4 ( 0.00%)  }
      .           
      .           float* PixelToWorld::pixelToWorld(float pixel[2], float depth) const
 70,566 ( 0.03%)  {
117,610 ( 0.05%)      if (!m_intrinsicsSet || !m_poseSet) {
      .                   // qWarning() << "Camera intrinsics or pose not set";
      .                   return NULL;
      .               }
      .           
105,849 ( 0.05%)      return pixelToWorld(pixel, depth, m_intrinsics, m_pose);
2,196,907 ( 1.03%)  => ../../FusionUtils/pixel2world.cpp:PixelToWorld::pixelToWorld(float const*, float, PixelToWorld::CameraIntrinsics const&, PixelToWorld::CameraPose const&) (11,761x)
 23,522 ( 0.01%)  }
      .           
      .           float* PixelToWorld::pixelToWorld(const float pixel[2], float depth,
      .                                                const CameraIntrinsics& intrinsics,
      .                                                const CameraPose& pose)
117,610 ( 0.05%)  {
 94,088 ( 0.04%)      if (!isValidDepth(depth)) {
423,012 ( 0.20%)  => ../../FusionUtils/pixel2world.cpp:PixelToWorld::isValidDepth(float, float, float) (11,761x)
      .                   // qWarning() << "Invalid depth value:" << depth;
     32 ( 0.00%)          return NULL;
      .               }
      .           
129,195 ( 0.06%)      float x_norm = (pixel[0] - intrinsics.cx) / intrinsics.fx;
140,940 ( 0.07%)      float y_norm = (pixel[1] - intrinsics.cy) / intrinsics.fy;
      .           
 93,960 ( 0.04%)      float point_cam[3] = {x_norm * depth, y_norm * depth, depth};
      .           
      .           
      .               // map according to QT, yeah i read the fucking library
      .               float point_world[3];
 70,470 ( 0.03%)      point_world[0] = pose.rotationMatrix.m[0][0] * point_cam[0] +
 58,725 ( 0.03%)                          pose.rotationMatrix.m[0][1] * point_cam[1] +
 58,725 ( 0.03%)                          pose.rotationMatrix.m[0][2] * point_cam[2] +
 23,490 ( 0.01%)                          pose.rotationMatrix.m[0][3] * 1.0f;
 70,470 ( 0.03%)      point_world[1] = pose.rotationMatrix.m[1][0] * point_cam[0] +
 58,725 ( 0.03%)                          pose.rotationMatrix.m[1][1] * point_cam[1] +
 58,725 ( 0.03%)                          pose.rotationMatrix.m[1][2] * point_cam[2] +
 23,490 ( 0.01%)                          pose.rotationMatrix.m[1][3] * 1.0f;
 70,470 ( 0.03%)      point_world[2] = pose.rotationMatrix.m[2][0] * point_cam[0] +
 58,725 ( 0.03%)                          pose.rotationMatrix.m[2][1] * point_cam[1] +
 58,725 ( 0.03%)                          pose.rotationMatrix.m[2][2] * point_cam[2] +
 23,490 ( 0.01%)                          pose.rotationMatrix.m[2][3] * 1.0f;
 82,215 ( 0.04%)      float w =           pose.rotationMatrix.m[3][0] * point_cam[0] +
 58,725 ( 0.03%)                          pose.rotationMatrix.m[3][1] * point_cam[1] +
 46,980 ( 0.02%)                          pose.rotationMatrix.m[3][2] * point_cam[2] +
 23,490 ( 0.01%)                          pose.rotationMatrix.m[3][3] * 1.0f;
 35,235 ( 0.02%)      point_world[0] /= w;
 35,235 ( 0.02%)      point_world[1] /= w;
 35,235 ( 0.02%)      point_world[2] /= w;
      .           
 58,725 ( 0.03%)      point_world[0] += pose.position[0];
 58,725 ( 0.03%)      point_world[1] += pose.position[1];
 58,725 ( 0.03%)      point_world[2] += pose.position[2];
      .               //  = pose.rotationMatrix.map(point_cam) + pose.position;
      .           
 11,745 ( 0.01%)      return point_world;
 58,805 ( 0.03%)  }
      .           
      .           PixelToWorld::Matrix4x4 PixelToWorld::CameraPose::eulerToRotationMatrix(float roll, float pitch, float yaw)
      8 ( 0.00%)  {
     10 ( 0.00%)      float cx = std::cos(roll),  sx = std::sin(roll);
  1,031 ( 0.00%)  => /usr/include/c++/15.1.1/cmath:std::cos(float) (1x)
    988 ( 0.00%)  => /usr/include/c++/15.1.1/cmath:std::sin(float) (1x)
     10 ( 0.00%)      float cy = std::cos(pitch), sy = std::sin(pitch);
     23 ( 0.00%)  => /usr/include/c++/15.1.1/cmath:std::cos(float) (1x)
     25 ( 0.00%)  => /usr/include/c++/15.1.1/cmath:std::sin(float) (1x)
     10 ( 0.00%)      float cz = std::cos(yaw),   sz = std::sin(yaw);
     23 ( 0.00%)  => /usr/include/c++/15.1.1/cmath:std::cos(float) (1x)
     25 ( 0.00%)  => /usr/include/c++/15.1.1/cmath:std::sin(float) (1x)
      .           
      .               Matrix4x4 rotMatrix;
      .           
      .               // Combined rotation: R = R_z(yaw) * R_y(pitch) * R_x(roll)
      .               // Row 0
      4 ( 0.00%)      rotMatrix.m[0][0] = cy * cz;
      6 ( 0.00%)      rotMatrix.m[0][1] = -cy * sz;
      3 ( 0.00%)      rotMatrix.m[0][2] = sy;
      3 ( 0.00%)      rotMatrix.m[0][3] = 0.0f;
      .           
      .               // Row 1
      9 ( 0.00%)      rotMatrix.m[1][0] = sx * sy * cz + cx * sz;
     11 ( 0.00%)      rotMatrix.m[1][1] = -sx * sy * sz + cx * cz;
      6 ( 0.00%)      rotMatrix.m[1][2] = -sx * cy;
      3 ( 0.00%)      rotMatrix.m[1][3] = 0.0f;
      .           
      .               // Row 2
     11 ( 0.00%)      rotMatrix.m[2][0] = -cx * sy * cz + sx * sz;
      9 ( 0.00%)      rotMatrix.m[2][1] = cx * sy * sz + sx * cz;
      4 ( 0.00%)      rotMatrix.m[2][2] = cx * cy;
      3 ( 0.00%)      rotMatrix.m[2][3] = 0.0f;
      .           
      .               // Row 3
      3 ( 0.00%)      rotMatrix.m[3][0] = 0.0f;
      3 ( 0.00%)      rotMatrix.m[3][1] = 0.0f;
      3 ( 0.00%)      rotMatrix.m[3][2] = 0.0f;
      3 ( 0.00%)      rotMatrix.m[3][3] = 1.0f;
      .           
      1 ( 0.00%)      return rotMatrix;
      3 ( 0.00%)  }
      .           
      .           bool PixelToWorld::isValidDepth(float depth, float minDepth, float maxDepth)
 70,566 ( 0.03%)  {
152,749 ( 0.07%)      return (depth > minDepth && depth < maxDepth && std::isfinite(depth));
176,175 ( 0.08%)  => /usr/include/c++/15.1.1/cmath:std::isfinite(float) (11,745x)
 23,522 ( 0.01%)  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/vector.tcc
--------------------------------------------------------------------------------
Ir              

-- line 59 ----------------------------------------
     .           namespace std _GLIBCXX_VISIBILITY(default)
     .           {
     .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
     .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
     .           
     .             template<typename _Tp, typename _Alloc>
     .               _GLIBCXX20_CONSTEXPR
     .               void
 8,865 ( 0.00%)      vector<_Tp, _Alloc>::
     .               reserve(size_type __n)
     .               {
12,411 ( 0.01%)        if (__n > this->max_size())
94,560 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::max_size() const (1,576x)
     .           	__throw_length_error(__N("vector::reserve"));
12,411 ( 0.01%)        if (this->capacity() < __n)
25,216 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::capacity() const (1,576x)
     .           	{
 7,092 ( 0.00%)  	  const size_type __old_size = size();
25,216 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::size() const (1,576x)
     .           	  pointer __tmp;
     .           #if __cplusplus >= 201103L
     .           	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
     .           	    {
10,638 ( 0.00%)  	      __tmp = this->_M_allocate(__n);
167,724 ( 0.08%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_allocate(unsigned long) (1,576x)
12,411 ( 0.01%)  	      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
97,712 ( 0.05%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_S_relocate(Fusion::PixelData*, Fusion::PixelData*, Fusion::PixelData*, std::allocator<Fusion::PixelData>&) (1,576x)
 7,092 ( 0.00%)  			  __tmp, _M_get_Tp_allocator());
 9,456 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_get_Tp_allocator() (1,576x)
     .           	    }
     .           	  else
     .           #endif
     .           	    {
     .           	      __tmp = _M_allocate_and_copy(__n,
     .           		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
     .           		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
     .           	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     .           			    _M_get_Tp_allocator());
     .           	    }
     .           	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
14,184 ( 0.01%)  	  _M_deallocate(this->_M_impl._M_start,
17,336 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::PixelData, std::allocator<Fusion::PixelData> >::_M_deallocate(Fusion::PixelData*, unsigned long) (1,576x)
 3,546 ( 0.00%)  			this->_M_impl._M_end_of_storage
10,638 ( 0.00%)  			- this->_M_impl._M_start);
 5,319 ( 0.00%)  	  this->_M_impl._M_start = __tmp;
17,730 ( 0.01%)  	  this->_M_impl._M_finish = __tmp + __old_size;
17,730 ( 0.01%)  	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
     .           	}
 5,319 ( 0.00%)      }
     .           
     .           #if __cplusplus >= 201103L
     .             template<typename _Tp, typename _Alloc>
     .               template<typename... _Args>
     .           #if __cplusplus > 201402L
     .                 _GLIBCXX20_CONSTEXPR
     .                 typename vector<_Tp, _Alloc>::reference
     .           #else
-- line 108 ----------------------------------------
-- line 202 ----------------------------------------
     .           	  _M_erase_at_end(__first.base() + (end() - __last));
     .           	}
     .                 return __first;
     .               }
     .           
     .             template<typename _Tp, typename _Alloc>
     .               _GLIBCXX20_CONSTEXPR
     .               vector<_Tp, _Alloc>&
 2,758 ( 0.00%)      vector<_Tp, _Alloc>::
     .               operator=(const vector<_Tp, _Alloc>& __x)
     .               {
   788 ( 0.00%)        if (std::__addressof(__x) != this)
     .           	{
     .           	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
     .           #if __cplusplus >= 201103L
   394 ( 0.00%)  	  if (_Alloc_traits::_S_propagate_on_copy_assign())
     .           	    {
     .           	      if (!_Alloc_traits::_S_always_equal()
     .           	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
     .           	        {
     .           		  // replacement allocator cannot free existing storage
     .           		  this->clear();
     .           		  _M_deallocate(this->_M_impl._M_start,
     .           				this->_M_impl._M_end_of_storage
-- line 225 ----------------------------------------
-- line 227 ----------------------------------------
     .           		  this->_M_impl._M_start = nullptr;
     .           		  this->_M_impl._M_finish = nullptr;
     .           		  this->_M_impl._M_end_of_storage = nullptr;
     .           		}
     .           	      std::__alloc_on_copy(_M_get_Tp_allocator(),
     .           				   __x._M_get_Tp_allocator());
     .           	    }
     .           #endif
   788 ( 0.00%)  	  const size_type __xlen = __x.size();
 2,955 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (197x)
 1,379 ( 0.00%)  	  if (__xlen > capacity())
 2,955 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::capacity() const (197x)
     .           	    {
    14 ( 0.00%)  	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
    20 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::end() const (1x)
    19 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::begin() const (1x)
   281 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:Fusion::RadarData* std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_allocate_and_copy<__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > >(unsigned long, __gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >) (1x)
     .           						   __x.end());
     7 ( 0.00%)  	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     3 ( 0.00%)  			    _M_get_Tp_allocator());
     6 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_get_Tp_allocator() (1x)
     8 ( 0.00%)  	      _M_deallocate(this->_M_impl._M_start,
    11 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_deallocate(Fusion::RadarData*, unsigned long) (1x)
     2 ( 0.00%)  			    this->_M_impl._M_end_of_storage
     5 ( 0.00%)  			    - this->_M_impl._M_start);
     3 ( 0.00%)  	      this->_M_impl._M_start = __tmp;
     8 ( 0.00%)  	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     .           	    }
 1,372 ( 0.00%)  	  else if (size() >= __xlen)
 2,940 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (196x)
     .           	    {
 4,312 ( 0.00%)  	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
34,300 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_algobase.h:__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > std::copy<__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > >(__gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData const*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >) (196x)
 3,920 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::end() const (196x)
 3,920 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::end() (196x)
 3,724 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::begin() const (196x)
 3,724 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::begin() (196x)
   784 ( 0.00%)  			    end(), _M_get_Tp_allocator());
 1,176 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_get_Tp_allocator() (196x)
     .           	    }
     .           	  else
     .           	    {
     .           	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
     .           			this->_M_impl._M_start);
     .           	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
     .           					  __x._M_impl._M_finish,
     .           					  this->_M_impl._M_finish,
     .           					  _M_get_Tp_allocator());
     .           	    }
 1,379 ( 0.00%)  	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
     .           	}
   197 ( 0.00%)        return *this;
 1,970 ( 0.00%)      }
     .           
     .             template<typename _Tp, typename _Alloc>
     .               _GLIBCXX20_CONSTEXPR
     .               void
     .               vector<_Tp, _Alloc>::
     .               _M_fill_assign(size_t __n, const value_type& __val)
     .               {
     .                 const size_type __sz = size();
-- line 273 ----------------------------------------
-- line 749 ----------------------------------------
     .           	    }
     .           	}
     .               }
     .           
     .           #if __cplusplus >= 201103L
     .             template<typename _Tp, typename _Alloc>
     .               _GLIBCXX20_CONSTEXPR
     .               void
     9 ( 0.00%)      vector<_Tp, _Alloc>::
     .               _M_default_append(size_type __n)
     .               {
     2 ( 0.00%)        if (__n != 0)
     .           	{
     4 ( 0.00%)  	  const size_type __size = size();
    15 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (1x)
     3 ( 0.00%)  	  size_type __navail = size_type(this->_M_impl._M_end_of_storage
     5 ( 0.00%)  					 - this->_M_impl._M_finish);
     .           
    13 ( 0.00%)  	  if (__size > max_size() || __navail > max_size() - __size)
   120 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::max_size() const (2x)
     .           	    __builtin_unreachable();
     .           
     3 ( 0.00%)  	  if (__navail >= __n)
     .           	    {
     .           	      if (!this->_M_impl._M_finish)
     .           		__builtin_unreachable();
     .           
     .           	      _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
     .           	      this->_M_impl._M_finish =
     .           		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
     .           						 __n, _M_get_Tp_allocator());
     .           	      _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
     .           	    }
     .           	  else
     .           	    {
     .           	      // Make local copies of these members because the compiler thinks
     .           	      // the allocator can alter them if 'this' is globally reachable.
     3 ( 0.00%)  	      pointer __old_start = this->_M_impl._M_start;
     3 ( 0.00%)  	      pointer __old_finish = this->_M_impl._M_finish;
     .           
     .           	      const size_type __len =
     7 ( 0.00%)  		_M_check_len(__n, "vector::_M_default_append");
   251 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_check_len(unsigned long, char const*) const (1x)
     6 ( 0.00%)  	      pointer __new_start(this->_M_allocate(__len));
   250 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_allocate(unsigned long) (1x)
     .           
     .           	      {
     6 ( 0.00%)  		_Guard_alloc __guard(__new_start, __len, *this);
    18 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_Guard_alloc::_Guard_alloc(Fusion::RadarData*, unsigned long, std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >&) (1x)
     .           
     9 ( 0.00%)  		std::__uninitialized_default_n_a(__new_start + __size, __n,
   195 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_uninitialized.h:Fusion::RadarData* std::__uninitialized_default_n_a<Fusion::RadarData*, unsigned long, Fusion::RadarData>(Fusion::RadarData*, unsigned long, std::allocator<Fusion::RadarData>&) (1x)
     4 ( 0.00%)  						 _M_get_Tp_allocator());
     6 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_get_Tp_allocator() (1x)
     .           
     .           		if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
     .           		  {
     5 ( 0.00%)  		    _S_relocate(__old_start, __old_finish,
    56 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_S_relocate(Fusion::RadarData*, Fusion::RadarData*, Fusion::RadarData*, std::allocator<Fusion::RadarData>&) (1x)
     4 ( 0.00%)  				__new_start, _M_get_Tp_allocator());
     6 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::_Vector_base<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_M_get_Tp_allocator() (1x)
     .           		  }
     .           		else
     .           		  {
     .           		    // RAII type to destroy initialized elements.
     .           		    struct _Guard_elts
     .           		    {
     .           		      pointer _M_first, _M_last;  // Elements to destroy
     .           		      _Tp_alloc_type& _M_alloc;
-- line 808 ----------------------------------------
-- line 825 ----------------------------------------
     .           		    std::__uninitialized_move_if_noexcept_a(
     .           		      __old_start, __old_finish, __new_start,
     .           		      _M_get_Tp_allocator());
     .           
     .           		    __guard_elts._M_first = __old_start;
     .           		    __guard_elts._M_last = __old_finish;
     .           		  }
     .           		_GLIBCXX_ASAN_ANNOTATE_REINIT;
     2 ( 0.00%)  		__guard._M_storage = __old_start;
     5 ( 0.00%)  		__guard._M_len = this->_M_impl._M_end_of_storage - __old_start;
     3 ( 0.00%)  	      }
    11 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::_Guard_alloc::~_Guard_alloc() (1x)
     .           	      // deallocate should be called before assignments to _M_impl,
     .           	      // to avoid call-clobbering
     .           
     3 ( 0.00%)  	      this->_M_impl._M_start = __new_start;
     9 ( 0.00%)  	      this->_M_impl._M_finish = __new_start + __size + __n;
     7 ( 0.00%)  	      this->_M_impl._M_end_of_storage = __new_start + __len;
     .           	    }
     .           	}
     8 ( 0.00%)      }
     .           
     .             template<typename _Tp, typename _Alloc>
     .               _GLIBCXX20_CONSTEXPR
     .               bool
     .               vector<_Tp, _Alloc>::
     .               _M_shrink_to_fit()
     .               {
     .                 if (capacity() == size())
-- line 852 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qarraydataops.h
--------------------------------------------------------------------------------
Ir               

-- line 74 ----------------------------------------
      .               {
      .                   Q_ASSERT(this->isMutable());
      .                   Q_ASSERT(!this->isShared());
      .                   Q_ASSERT(newSize < size_t(this->size));
      .           
      .                   this->size = qsizetype(newSize);
      .               }
      .           
158,792 ( 0.07%)      void destroyAll() noexcept // Call from destructors, ONLY!
      .               {
158,792 ( 0.07%)          Q_ASSERT(this->d);
238,188 ( 0.11%)          Q_ASSERT(this->d->ref_.loadRelaxed() == 0);
1,690,072 ( 0.79%)  => /usr/include/qt6/QtCore/qbasicatomic.h:QBasicAtomicInteger<int>::loadRelaxed() const (39,304x)
      .           
      .                   // As this is to be called only from destructor, it doesn't need to be
      .                   // exception safe; size not updated.
119,094 ( 0.06%)      }
      .           
  2,758 ( 0.00%)      T *createHole(QArrayData::GrowthPosition pos, qsizetype where, qsizetype n)
      .               {
  3,546 ( 0.00%)          Q_ASSERT((pos == QArrayData::GrowsAtBeginning && n <= this->freeSpaceAtBegin()) ||
 31,126 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtEnd() const (394x)
      .                            (pos == QArrayData::GrowsAtEnd && n <= this->freeSpaceAtEnd()));
      .           
  2,364 ( 0.00%)          T *insertionPoint = this->ptr + where;
    788 ( 0.00%)          if (pos == QArrayData::GrowsAtEnd) {
  1,576 ( 0.00%)              if (where < this->size)
      .                           ::memmove(static_cast<void *>(insertionPoint + n), static_cast<void *>(insertionPoint), (this->size - where) * sizeof(T));
      .                   } else {
      .                       Q_ASSERT(where == 0);
      .                       this->ptr -= n;
      .                       insertionPoint -= n;
      .                   }
  2,364 ( 0.00%)          this->size += n;
    394 ( 0.00%)          return insertionPoint;
    788 ( 0.00%)      }
      .           
      .               void insert(qsizetype i, const T *data, qsizetype n)
      .               {
      .                   typename Data::GrowthPosition pos = Data::GrowsAtEnd;
      .                   if (this->size != 0 && i == 0)
      .                       pos = Data::GrowsAtBeginning;
      .           
      .                   DataPointer oldData;
-- line 115 ----------------------------------------
-- line 134 ----------------------------------------
      .                            (pos == Data::GrowsAtEnd && this->freeSpaceAtEnd() >= n));
      .           
      .                   T *where = createHole(pos, i, n);
      .                   while (n--)
      .                       *where++ = copy;
      .               }
      .           
      .               template<typename... Args>
 15,760 ( 0.01%)      void emplace(qsizetype i, Args &&... args)
      .               {
  6,304 ( 0.00%)          bool detach = this->needsDetach();
100,273 ( 0.05%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::needsDetach() const (1,576x)
  6,304 ( 0.00%)          if (!detach) {
 17,730 ( 0.01%)              if (i == this->size && this->freeSpaceAtEnd()) {
108,941 ( 0.05%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtEnd() const (1,379x)
 16,548 ( 0.01%)                  new (this->end()) T(std::forward<Args>(args)...);
 23,640 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::end() (1,182x)
  8,274 ( 0.00%)  => /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) (1,182x)
  5,910 ( 0.00%)                  ++this->size;
  1,182 ( 0.00%)                  return;
      .                       }
    985 ( 0.00%)              if (i == 0 && this->freeSpaceAtBegin()) {
      .                           new (this->begin() - 1) T(std::forward<Args>(args)...);
      .                           --this->ptr;
      .                           ++this->size;
    788 ( 0.00%)                  return;
      .                       }
      .                   }
    788 ( 0.00%)          T tmp(std::forward<Args>(args)...);
    394 ( 0.00%)          typename QArrayData::GrowthPosition pos = QArrayData::GrowsAtEnd;
  1,970 ( 0.00%)          if (this->size != 0 && i == 0)
      .                       pos = QArrayData::GrowsAtBeginning;
      .           
  2,758 ( 0.00%)          this->detachAndGrow(pos, 1, nullptr, nullptr);
412,238 ( 0.19%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::detachAndGrow(QArrayData::GrowthPosition, long long, unsigned int const**, QArrayDataPointer<unsigned int>*) (394x)
      .           
  2,758 ( 0.00%)          T *where = createHole(pos, i, 1);
 45,704 ( 0.02%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QPodArrayOps<unsigned int>::createHole(QArrayData::GrowthPosition, long long, long long) (394x)
  3,546 ( 0.00%)          new (where) T(std::move(tmp));
  2,758 ( 0.00%)  => /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) (394x)
  9,456 ( 0.00%)      }
      .           
      .               void erase(T *b, qsizetype n)
      .               {
      .                   T *e = b + n;
      .                   Q_ASSERT(this->isMutable());
      .                   Q_ASSERT(b < e);
      .                   Q_ASSERT(b >= this->begin() && b < this->end());
      .                   Q_ASSERT(e > this->begin() && e <= this->end());
-- line 175 ----------------------------------------
-- line 251 ----------------------------------------
      .               {
      .                   Q_ASSERT(b <= e);
      .                   Q_ASSERT(b >= this->begin() && e <= this->end());
      .           
      .                   while (b != e)
      .                       ::memcpy(static_cast<void *>(b++), static_cast<const void *>(&t), sizeof(T));
      .               }
      .           
  1,182 ( 0.00%)      void reallocate(qsizetype alloc, QArrayData::AllocationOption option)
      .               {
  1,970 ( 0.00%)          auto pair = Data::reallocateUnaligned(this->d, this->ptr, alloc, option);
 94,809 ( 0.04%)  => /usr/include/qt6/QtCore/qarraydata.h:QTypedArrayData<unsigned int>::reallocateUnaligned(QTypedArrayData<unsigned int>*, unsigned int*, long long, QArrayData::AllocationOption) (197x)
    591 ( 0.00%)          Q_CHECK_PTR(pair.second);
    591 ( 0.00%)          Q_ASSERT(pair.first != nullptr);
    591 ( 0.00%)          this->d = pair.first;
    591 ( 0.00%)          this->ptr = pair.second;
    591 ( 0.00%)      }
      .           };
      .           
      .           template <class T>
      .           struct QGenericArrayOps
      .                   : public QArrayDataPointer<T>
      .           {
      .               static_assert (std::is_nothrow_destructible_v<T>, "Types with throwing destructors are not supported in Qt containers.");
      .           
-- line 274 ----------------------------------------
-- line 306 ----------------------------------------
      .           
      .                   T *data = this->begin();
      .                   while (n--) {
      .                       new (data + this->size) T(t);
      .                       ++this->size;
      .                   }
      .               }
      .           
     56 ( 0.00%)      void moveAppend(T *b, T *e)
      .               {
     35 ( 0.00%)          Q_ASSERT(this->isMutable() || b == e);
     63 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::isMutable() const (7x)
     42 ( 0.00%)          Q_ASSERT(!this->isShared() || b == e);
    497 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::isShared() const (7x)
     21 ( 0.00%)          Q_ASSERT(b <= e);
     84 ( 0.00%)          Q_ASSERT((e - b) <= this->freeSpaceAtEnd());
    560 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::freeSpaceAtEnd() const (7x)
      .           
     21 ( 0.00%)          if (b == e)
      .                       return;
      .           
     28 ( 0.00%)          T *data = this->begin();
    112 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::begin() (7x)
  1,031 ( 0.00%)          while (b < e) {
  7,304 ( 0.00%)              new (data + this->size) T(std::move(*b));
 27,224 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::vector(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >&&) (332x)
  2,324 ( 0.00%)  => /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) (332x)
    332 ( 0.00%)              ++b;
  1,660 ( 0.00%)              ++this->size;
      .                   }
     35 ( 0.00%)      }
      .           
      .               void truncate(size_t newSize)
      .               {
      .                   Q_ASSERT(this->isMutable());
      .                   Q_ASSERT(!this->isShared());
      .                   Q_ASSERT(newSize < size_t(this->size));
      .           
      .                   std::destroy(this->begin() + newSize, this->end());
      .                   this->size = newSize;
      .               }
      .           
     35 ( 0.00%)      void destroyAll() // Call from destructors, ONLY
      .               {
     28 ( 0.00%)          Q_ASSERT(this->d);
      .                   // As this is to be called only from destructor, it doesn't need to be
      .                   // exception safe; size not updated.
      .           
     42 ( 0.00%)          Q_ASSERT(this->d->ref_.loadRelaxed() == 0);
    301 ( 0.00%)  => /usr/include/qt6/QtCore/qbasicatomic.h:QBasicAtomicInteger<int>::loadRelaxed() const (7x)
      .           
     70 ( 0.00%)          std::destroy(this->begin(), this->end());
 37,366 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_construct.h:void std::destroy<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*>(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*) (7x)
    175 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::end() (7x)
    112 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::begin() (7x)
     28 ( 0.00%)      }
      .           
      .               struct Inserter
      .               {
      .                   QArrayDataPointer<T> *data;
      .                   T *begin;
      .                   qsizetype size;
      .           
      .                   qsizetype sourceCopyConstruct = 0, nSource = 0, move = 0, sourceCopyAssign = 0;
      .                   T *end = nullptr, *last = nullptr, *where = nullptr;
      .           
    168 ( 0.00%)          Inserter(QArrayDataPointer<T> *d) : data(d)
      .                   {
     32 ( 0.00%)              begin = d->ptr;
     32 ( 0.00%)              size = d->size;
     24 ( 0.00%)          }
     24 ( 0.00%)          ~Inserter() {
     40 ( 0.00%)              data->ptr = begin;
     40 ( 0.00%)              data->size = size;
     24 ( 0.00%)          }
      .                   Q_DISABLE_COPY(Inserter)
      .           
     40 ( 0.00%)          void setup(qsizetype pos, qsizetype n)
      .                   {
     96 ( 0.00%)              end = begin + size;
     40 ( 0.00%)              last = end - 1;
     80 ( 0.00%)              where = begin + pos;
     32 ( 0.00%)              qsizetype dist = size - pos;
     16 ( 0.00%)              sourceCopyConstruct = 0;
     24 ( 0.00%)              nSource = n;
     40 ( 0.00%)              move = n - dist; // smaller 0
     24 ( 0.00%)              sourceCopyAssign = n;
     24 ( 0.00%)              if (n > dist) {
     40 ( 0.00%)                  sourceCopyConstruct = n - dist;
     16 ( 0.00%)                  move = 0;
     56 ( 0.00%)                  sourceCopyAssign -= sourceCopyConstruct;
      .                       }
     24 ( 0.00%)          }
      .           
      .                   void insert(qsizetype pos, const T *source, qsizetype n)
      .                   {
      .                       qsizetype oldSize = size;
      .                       Q_UNUSED(oldSize);
      .           
      .                       setup(pos, n);
      .           
-- line 396 ----------------------------------------
-- line 448 ----------------------------------------
      .                       for (qsizetype i = 0; i != move; --i)
      .                           last[i] = std::move(last[i - nSource]);
      .           
      .                       // finally copy the remaining elements from source over
      .                       for (qsizetype i = 0; i != sourceCopyAssign; ++i)
      .                           where[i] = t;
      .                   }
      .           
     64 ( 0.00%)          void insertOne(qsizetype pos, T &&t)
      .                   {
     48 ( 0.00%)              setup(pos, 1);
    552 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QGenericArrayOps<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::Inserter::setup(long long, long long) (8x)
      .           
     32 ( 0.00%)              if (sourceCopyConstruct) {
     32 ( 0.00%)                  Q_ASSERT(sourceCopyConstruct == 1);
    112 ( 0.00%)                  new (end) T(std::move(t));
    656 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::vector(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >&&) (8x)
     56 ( 0.00%)  => /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) (8x)
     40 ( 0.00%)                  ++size;
      .                       } else {
      .                           // create a new element at the end by move constructing one existing element
      .                           // inside the array.
      .                           new (end) T(std::move(*(end - 1)));
      .                           ++size;
      .           
      .                           // now move assign existing elements towards the end
      .                           for (qsizetype i = 0; i != move; --i)
      .                               last[i] = std::move(last[i - 1]);
      .           
      .                           // and move the new item into place
      .                           *where = std::move(t);
      .                       }
     56 ( 0.00%)          }
      .               };
      .           
      .               void insert(qsizetype i, const T *data, qsizetype n)
      .               {
      .                   const bool growsAtBegin = this->size != 0 && i == 0;
      .                   const auto pos = growsAtBegin ? Data::GrowsAtBeginning : Data::GrowsAtEnd;
      .           
      .                   DataPointer oldData;
-- line 485 ----------------------------------------
-- line 521 ----------------------------------------
      .                           ++this->size;
      .                       }
      .                   } else {
      .                       Inserter(this).insert(i, copy, n);
      .                   }
      .               }
      .           
      .               template<typename... Args>
  2,561 ( 0.00%)      void emplace(qsizetype i, Args &&... args)
      .               {
    788 ( 0.00%)          bool detach = this->needsDetach();
 13,928 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::needsDetach() const (197x)
    788 ( 0.00%)          if (!detach) {
  2,541 ( 0.00%)              if (i == this->size && this->freeSpaceAtEnd()) {
 15,680 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::freeSpaceAtEnd() const (196x)
  3,213 ( 0.00%)                  new (this->end()) T(std::forward<Args>(args)...);
 96,626 ( 0.05%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::vector(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const&) (189x)
  4,725 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::end() (189x)
  1,323 ( 0.00%)  => /usr/include/c++/15.1.1/new:operator new(unsigned long, void*) (189x)
    945 ( 0.00%)                  ++this->size;
    189 ( 0.00%)                  return;
      .                       }
     35 ( 0.00%)              if (i == 0 && this->freeSpaceAtBegin()) {
      .                           new (this->begin() - 1) T(std::forward<Args>(args)...);
      .                           --this->ptr;
      .                           ++this->size;
     16 ( 0.00%)                  return;
      .                       }
      .                   }
     32 ( 0.00%)          T tmp(std::forward<Args>(args)...);
  4,167 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::vector(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const&) (8x)
     62 ( 0.00%)          const bool growsAtBegin = this->size != 0 && i == 0;
     24 ( 0.00%)          const auto pos = growsAtBegin ? Data::GrowsAtBeginning : Data::GrowsAtEnd;
      .           
     56 ( 0.00%)          this->detachAndGrow(pos, 1, nullptr, nullptr);
 98,204 ( 0.05%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::detachAndGrow(QArrayData::GrowthPosition, long long, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const**, QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*) (8x)
      .           
     16 ( 0.00%)          if (growsAtBegin) {
      .                       Q_ASSERT(this->freeSpaceAtBegin());
      .                       new (this->begin() - 1) T(std::move(tmp));
      .                       --this->ptr;
      .                       ++this->size;
      .                   } else {
    104 ( 0.00%)              Inserter(this).insertOne(i, std::move(tmp));
  1,656 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QGenericArrayOps<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::Inserter::insertOne(long long, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >&&) (8x)
    256 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QGenericArrayOps<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::Inserter::Inserter(QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*) (8x)
    128 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QGenericArrayOps<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::Inserter::~Inserter() (8x)
      .                   }
  2,002 ( 0.00%)      }
    744 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::~vector() (8x)
      .           
      .               void erase(T *b, qsizetype n)
      .               {
      .                   T *e = b + n;
      .                   Q_ASSERT(this->isMutable());
      .                   Q_ASSERT(b < e);
      .                   Q_ASSERT(b >= this->begin() && b < this->end());
      .                   Q_ASSERT(e > this->begin() && e <= this->end());
-- line 567 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/alloc_traits.h
--------------------------------------------------------------------------------
Ir              

-- line 606 ----------------------------------------
     .                  *  @param  __a  An allocator.
     .                  *  @param  __n  The number of objects to allocate space for.
     .                  *
     .                  *  Calls @c a.allocate(n)
     .                 */
     .                 [[__nodiscard__,__gnu__::__always_inline__]]
     .                 static _GLIBCXX20_CONSTEXPR pointer
     .                 allocate(allocator_type& __a, size_type __n)
29,960 ( 0.01%)        { return __a.allocate(__n); }
16,745 ( 0.01%)  => /usr/include/c++/15.1.1/bits/new_allocator.h:std::__new_allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >::allocate(unsigned long, void const*) (197x)
     .           
     .                 /**
     .                  *  @brief  Allocate memory.
     .                  *  @param  __a  An allocator.
     .                  *  @param  __n  The number of objects to allocate space for.
     .                  *  @param  __hint Aid to locality.
     .                  *  @return Memory of suitable size and alignment for @a n objects
     .                  *          of type @c value_type
-- line 622 ----------------------------------------
-- line 641 ----------------------------------------
     .                  *  @param  __p  Pointer to the memory to deallocate.
     .                  *  @param  __n  The number of objects space was allocated for.
     .                  *
     .                  *  Calls <tt> a.deallocate(p, n) </tt>
     .                 */
     .                 [[__gnu__::__always_inline__]]
     .                 static _GLIBCXX20_CONSTEXPR void
     .                 deallocate(allocator_type& __a, pointer __p, size_type __n)
24,822 ( 0.01%)        { __a.deallocate(__p, __n); }
16,351 ( 0.01%)  => /usr/include/c++/15.1.1/bits/new_allocator.h:std::__new_allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > >::deallocate(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >*, unsigned long) (197x)
     .           
     .                 /**
     .                  *  @brief  Construct an object of type `_Up`
     .                  *  @param  __a  An allocator.
     .                  *  @param  __p  Pointer to memory of suitable size and alignment for
     .                  *	       an object of type `_Up`.
     .                  *  @param  __args Constructor arguments.
     .                  *
-- line 657 ----------------------------------------
-- line 672 ----------------------------------------
     .           	{
     .           #if __cplusplus <= 201703L
     .           	  __a.construct(__p, std::forward<_Args>(__args)...);
     .           #elif __cpp_constexpr_dynamic_alloc // >= C++20
     .           	  std::construct_at(__p, std::forward<_Args>(__args)...);
     .           #else
     .           	  std::_Construct(__p, std::forward<_Args>(__args)...);
     .           #endif
13,364 ( 0.01%)  	}
     .           
     .                 /**
     .                  *  @brief  Destroy an object of type @a _Up
     .                  *  @param  __a  An allocator.
     .                  *  @param  __p  Pointer to the object to destroy
     .                  *
     .                  *  Calls @c __a.destroy(__p).
     .                 */
-- line 688 ----------------------------------------
-- line 704 ----------------------------------------
     .                  *  @param  __a  An allocator.
     .                  *  @return @c __a.max_size()
     .                 */
     .                 [[__gnu__::__always_inline__]]
     .                 static _GLIBCXX20_CONSTEXPR size_type
     .                 max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
     .                 {
     .           #if __cplusplus <= 201703L
 1,974 ( 0.00%)  	return __a.max_size();
     .           #else
     .           	return size_t(-1) / sizeof(value_type);
     .           #endif
     .                 }
     .           
     .                 /**
     .                  *  @brief  Obtain an allocator to use when copying a container.
     .                  *  @param  __rhs  An allocator.
     .                  *  @return @c __rhs
     .                 */
     .                 [[__gnu__::__always_inline__]]
     .                 static _GLIBCXX20_CONSTEXPR allocator_type
     .                 select_on_container_copy_construction(const allocator_type& __rhs)
 1,773 ( 0.00%)        { return __rhs; }
     .               };
     .           
     .             /**
     .              * @brief  Explicit specialization for `std::allocator<void>`
     .              * @headerfile memory
     .              * @ingroup allocators
     .              * @since C++11
     .              * @see std::allocator_traits
-- line 734 ----------------------------------------
-- line 863 ----------------------------------------
     .               _GLIBCXX14_CONSTEXPR inline void
     .               __alloc_on_move(_Alloc& __one, _Alloc& __two)
     .               {
     .                 using __traits = allocator_traits<_Alloc>;
     .                 using __pocma
     .           	= typename __traits::propagate_on_container_move_assignment::type;
     .                 if constexpr (__pocma::value)
     .           	__one = std::move(__two);
   197 ( 0.00%)      }
     .           
     .             template<typename _Alloc>
     .               [[__gnu__::__always_inline__]]
     .               _GLIBCXX14_CONSTEXPR inline void
     .               __alloc_on_swap(_Alloc& __one, _Alloc& __two)
     .               {
     .                 using __traits = allocator_traits<_Alloc>;
     .                 using __pocs = typename __traits::propagate_on_container_swap::type;
-- line 879 ----------------------------------------
-- line 1037 ----------------------------------------
     .           
     .           #if _GLIBCXX_HOSTED
     .             template<typename _ForwardIterator, typename _Tp>
     .               __attribute__((__always_inline__)) _GLIBCXX20_CONSTEXPR
     .               inline void
     .               _Destroy(_ForwardIterator __first, _ForwardIterator __last,
     .           	     allocator<_Tp>&)
     .               {
22,385 ( 0.01%)        std::_Destroy(__first, __last);
 1,372 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Destroy<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >) (196x)
     7 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_construct.h:void std::_Destroy<Fusion::RadarData*>(Fusion::RadarData*, Fusion::RadarData*) (1x)
 4,477 ( 0.00%)      }
     .           #endif
     .           
     .             /// @endcond
     .           
     .           _GLIBCXX_END_NAMESPACE_VERSION
     .           } // namespace std
     .           #endif // _ALLOC_TRAITS_H

--------------------------------------------------------------------------------
-- Auto-annotated source: ../../FusionUtils/fusion.cpp
--------------------------------------------------------------------------------
Ir               

      .           #include "fusion.h"
      .           #include <algorithm>
      .           #include <cmath>
      .           #include <limits>
      .           #include <QDebug>
      .           
      8 ( 0.00%)  Fusion::Fusion()
     10 ( 0.00%)      : m_epsilon(1.0f)
     48 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::vector() (1x)
     10 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/pixel2world.cpp:PixelToWorld::PixelToWorld() (1x)
      .           {
     11 ( 0.00%)      PixelToWorld::CameraIntrinsics ci = PixelToWorld::CameraIntrinsics(CAM_FX, CAM_FY, CAM_CX, CAM_CY);
     22 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/pixel2world.h:PixelToWorld::CameraIntrinsics::CameraIntrinsics(double, double, double, double) (1x)
      5 ( 0.00%)      this->setCameraIntrinsics(ci);
     32 ( 0.00%)  => ../../FusionUtils/fusion.cpp:Fusion::setCameraIntrinsics(PixelToWorld::CameraIntrinsics const&) (1x)
      7 ( 0.00%)  }
      .           
      .           void Fusion::setCameraIntrinsics(const PixelToWorld::CameraIntrinsics& intrinsics)
      5 ( 0.00%)  {
      5 ( 0.00%)      m_pixelToWorld.setCameraIntrinsics(intrinsics);
     19 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/pixel2world.cpp:PixelToWorld::setCameraIntrinsics(PixelToWorld::CameraIntrinsics const&) (1x)
      3 ( 0.00%)  }
      .           
      .           void Fusion::setCameraPose(const PixelToWorld::CameraPose& pose)
      5 ( 0.00%)  {
      5 ( 0.00%)      m_pixelToWorld.setCameraPose(pose);
     35 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/pixel2world.cpp:PixelToWorld::setCameraPose(PixelToWorld::CameraPose const&) (1x)
      3 ( 0.00%)  }
      .           
      .           void Fusion::setRadars(const std::vector<RadarData>& radars)    // Nlog^2(N)
  1,182 ( 0.00%)  {
  1,182 ( 0.00%)      m_radars = radars;
 79,077 ( 0.04%)  => /usr/include/c++/15.1.1/bits/vector.tcc:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator=(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&) (197x)
  2,364 ( 0.00%)      std::stable_sort(m_radars.begin(), m_radars.end(),
356,525 ( 0.17%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::stable_sort<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}) (197x)
  3,940 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::end() (197x)
  3,743 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::begin() (197x)
 10,835 ( 0.01%)                [](const RadarData& a, const RadarData& b) {
 13,002 ( 0.01%)                    return a.position_x < b.position_x;
  4,334 ( 0.00%)                });
    788 ( 0.00%)  }
      .           
      .           void Fusion::setEpsilon(float epsilon)
      .           {
      .               m_epsilon = epsilon;
      .           }
      .           
      .           std::vector<Fusion::FusionOutput> Fusion::performFusion(const ObjectVector& objects)
  2,364 ( 0.00%)  {
  1,970 ( 0.00%)      std::vector<FusionOutput> output(m_radars.size());
157,353 ( 0.07%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::vector(unsigned long, std::allocator<Fusion::FusionOutput> const&) (197x)
  2,955 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::size() const (197x)
      .               bool is_pixel_seen[IMG_HEIGHT][IMG_WIDTH];
  2,364 ( 0.00%)      std::fill(&is_pixel_seen[0][0], &is_pixel_seen[0][0] + sizeof(is_pixel_seen) / sizeof(bool), false); // O(Nimglen)
      .           
  7,289 ( 0.00%)      for (const auto& object : objects) { // O(Nimglen* (O(pixel2World) + 2Nradarlen + Nradarlen*O(logNfloatlen)))
  3,940 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::end() const (197x)
  3,743 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::begin() const (197x)
 55,852 ( 0.03%)          for (const auto& pixel : object) {
 31,520 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::end() const (1,576x)
 29,944 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::begin() const (1,576x)
      .           
188,608 ( 0.09%)              if (is_pixel_seen[static_cast<int>(pixel.pixel_pos_y)][static_cast<int>(pixel.pixel_pos_x)])
     54 ( 0.00%)                  continue;
      .                       else
164,654 ( 0.08%)                  is_pixel_seen[static_cast<int>(pixel.pixel_pos_y)][static_cast<int>(pixel.pixel_pos_x)] = true;
      .           
 70,566 ( 0.03%)              float pixel_coords[2] = {pixel.pixel_pos_x, pixel.pixel_pos_y};
105,849 ( 0.05%)              float* world_pos = m_pixelToWorld.pixelToWorld(pixel_coords, pixel.pixel_depth);
2,514,454 ( 1.18%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/pixel2world.cpp:PixelToWorld::pixelToWorld(float*, float) const (11,761x)
 23,522 ( 0.01%)              if (world_pos == nullptr)
 11,761 ( 0.01%)                  continue;
      .                       float world_x = world_pos[0];
      .                       float world_y = world_pos[1];
      .                       float world_z = world_pos[2];
      .                       
      .                       int left_radar, right_radar;
      .                       std::vector<int> relevant_radars;
      .                       
      .                       if (findBracketingRadars(world_x, left_radar, right_radar)) {
-- line 63 ----------------------------------------
-- line 88 ----------------------------------------
      .                           }
      .                       }
      .                       
      .                       delete[] world_pos;
      .                   }
      .               }
      .               
      .               return output;
  1,379 ( 0.00%)  }
      .           
      .           int Fusion::findClosestRadar(float world_x) // O(N)
      .           {
      .               if (m_radars.empty()) return -1;
      .               
      .               int closest_idx = 0;
      .               float min_distance = std::abs(world_x - m_radars[0].position_x);
      .               
-- line 104 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qbytearrayview.h
--------------------------------------------------------------------------------
Ir                 

-- line 61 ----------------------------------------
        .                           // We handle array literals specially for source compat reasons
        .                           std::negation<std::is_array<T>>,
        .           
        .                           // Don't make an accidental copy constructor
        .                           std::negation<std::is_same<std::decay_t<T>, QByteArrayView>>>>> : std::true_type {};
        .           
        .           // Used by QLatin1StringView too
        .           template <typename Char>
  117,912 ( 0.06%)  static constexpr qsizetype lengthHelperPointer(const Char *data) noexcept
        .           {
        .               // std::char_traits can only be used with one of the regular char types
        .               // (char, char16_t, wchar_t, but not uchar or QChar), so we roll the loop
        .               // out by ourselves.
   39,304 ( 0.02%)      qsizetype i = 0;
   78,608 ( 0.04%)      if (!data)
        .                   return i;
2,718,780 ( 1.27%)      while (data[i] != Char(0))
  413,826 ( 0.19%)          ++i;
   39,304 ( 0.02%)      return i;
   78,608 ( 0.04%)  }
        .           
        .           } // namespace QtPrivate
        .           
        .           class Q_CORE_EXPORT QByteArrayView
        .           {
        .           public:
        .               typedef char storage_type;
        .               typedef const char value_type;
-- line 88 ----------------------------------------
-- line 128 ----------------------------------------
        .                   const auto it = std::char_traits<char>::find(data, size, '\0');
        .                   const auto end = it ? it : std::next(data, size);
        .                   return qsizetype(std::distance(data, end));
        .               }
        .           
        .               template <typename Byte>
        .               static const storage_type *castHelper(const Byte *data) noexcept
        .               { return reinterpret_cast<const storage_type*>(data); }
  117,912 ( 0.06%)      static constexpr const storage_type *castHelper(const storage_type *data) noexcept
  117,912 ( 0.06%)      { return data; }
        .           
        .           public:
        .               constexpr QByteArrayView() noexcept
        .                   : m_size(0), m_data(nullptr) {}
        .               constexpr QByteArrayView(std::nullptr_t) noexcept
        .                   : QByteArrayView() {}
        .           
        .               template <typename Byte, if_compatible_byte<Byte> = true>
  235,824 ( 0.11%)      constexpr QByteArrayView(const Byte *data, qsizetype len)
  275,128 ( 0.13%)          : m_size((Q_ASSERT(len >= 0), Q_ASSERT(data || !len), len)),
  314,432 ( 0.15%)            m_data(castHelper(data)) {}
  235,824 ( 0.11%)  => /usr/include/qt6/QtCore/qbytearrayview.h:QByteArrayView::castHelper(char const*) (39,304x)
        .           
        .               template <typename Byte, if_compatible_byte<Byte> = true>
        .               constexpr QByteArrayView(const Byte *first, const Byte *last)
        .                   : QByteArrayView(first, last - first) {}
        .           
        .           #ifdef Q_QDOC
        .               template <typename Byte>
        .               constexpr QByteArrayView(const Byte *data) noexcept;
        .           #else
        .               template <typename Pointer, if_compatible_pointer<Pointer> = true>
  196,520 ( 0.09%)      constexpr QByteArrayView(const Pointer &data) noexcept
        .                   : QByteArrayView(
  746,776 ( 0.35%)                data, data ? QtPrivate::lengthHelperPointer(data) : 0) {}
3,486,342 ( 1.63%)  => /usr/include/qt6/QtCore/qbytearrayview.h:long long QtPrivate::lengthHelperPointer<char>(char const*) (39,304x)
1,061,208 ( 0.50%)  => /usr/include/qt6/QtCore/qbytearrayview.h:QByteArrayView::QByteArrayView<char, true>(char const*, long long) (39,304x)
        .           #endif
        .           
        .           #ifdef Q_QDOC
        .               QByteArrayView(const QByteArray &data) noexcept;
        .           #else
        .               template <typename ByteArray, if_compatible_qbytearray_like<ByteArray> = true>
        .               QByteArrayView(const ByteArray &ba) noexcept
        .                   : QByteArrayView{ba.begin(), ba.size()} {}
-- line 169 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: ../../FusionUtils/fusion.h
--------------------------------------------------------------------------------
Ir              

-- line 36 ----------------------------------------
     .               };
     .               
     .               struct FusionOutput {
     .                   float error;
     .                   float pixel_pos_x;
     .                   float pixel_pos_y;
     .                   bool is_valid;
     .                   
 9,456 ( 0.00%)          FusionOutput() : error(std::numeric_limits<float>::max()), 
 5,910 ( 0.00%)  => /usr/include/c++/15.1.1/limits:std::numeric_limits<float>::max() (1,182x)
13,002 ( 0.01%)                          pixel_pos_x(0.0f), pixel_pos_y(0.0f), is_valid(false) {}
     .               };
     .               
     .               using ObjectVector = std::vector<std::vector<PixelData>>;
     .           
     .           private:
     .               PixelToWorld m_pixelToWorld;
     .               std::vector<RadarData> m_radars;
     .               float m_epsilon;
-- line 53 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: ../../erfanmocker.cpp
--------------------------------------------------------------------------------
Ir               

      .           #include "erfanmocker.h"
      .           #include <QJsonArray> // Add this include
      .           
     12 ( 0.00%)  ErfanMocker::ErfanMocker(QObject *parent)
      .               : QObject(parent)
     16 ( 0.00%)      , server(new QTcpServer(this))
  1,112 ( 0.00%)  => ???:QTcpServer::QTcpServer(QObject*) (1x)
    205 ( 0.00%)  => /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (1x)
     12 ( 0.00%)      , clientSocket(nullptr)
    326 ( 0.00%)  => ???:QObject::QObject(QObject*) (1x)
      .           {
     24 ( 0.00%)      connect(server, &QTcpServer::newConnection, this, &ErfanMocker::onNewConnection);
  1,502 ( 0.00%)  => /usr/include/qt6/QtCore/qobject.h:QMetaObject::Connection QObject::connect<void (QTcpServer::*)(), void (ErfanMocker::*)()>(QtPrivate::FunctionPointer<void (QTcpServer::*)()>::Object const*, void (QTcpServer::*)(), QtPrivate::ContextTypeForFunctor<void (ErfanMocker::*)(), void>::ContextType const*, void (ErfanMocker::*&&)(), Qt::ConnectionType) (1x)
     13 ( 0.00%)  => ???:QMetaObject::Connection::~Connection() (1x)
     11 ( 0.00%)  }
      .           
      .           void ErfanMocker::startServer(quint16 port)
     11 ( 0.00%)  {
     18 ( 0.00%)      server->listen(QHostAddress::Any, port);
 10,355 ( 0.00%)  => ???:QTcpServer::listen(QHostAddress const&, unsigned short) (1x)
    132 ( 0.00%)  => ???:QHostAddress::QHostAddress(QHostAddress::SpecialAddress) (1x)
     89 ( 0.00%)  => ???:QHostAddress::~QHostAddress() (1x)
      9 ( 0.00%)  }
      .           
      .           void ErfanMocker::onNewConnection()
     11 ( 0.00%)  {
     11 ( 0.00%)      clientSocket = server->nextPendingConnection();
     45 ( 0.00%)  => ???:QTcpServer::nextPendingConnection() (1x)
     25 ( 0.00%)      connect(clientSocket, &QTcpSocket::readyRead, this, &ErfanMocker::onReadyRead);
  1,287 ( 0.00%)  => /usr/include/qt6/QtCore/qobject.h:QMetaObject::Connection QObject::connect<void (QIODevice::*)(), void (ErfanMocker::*)()>(QtPrivate::FunctionPointer<void (QIODevice::*)()>::Object const*, void (QIODevice::*)(), QtPrivate::ContextTypeForFunctor<void (ErfanMocker::*)(), void>::ContextType const*, void (ErfanMocker::*&&)(), Qt::ConnectionType) (1x)
     13 ( 0.00%)  => ???:QMetaObject::Connection::~Connection() (1x)
     11 ( 0.00%)  }
      .           
      .           void ErfanMocker::onReadyRead()
  1,576 ( 0.00%)  {
  1,580 ( 0.00%)      QByteArray data = clientSocket->readAll();
1,769,691 ( 0.83%)  => ???:QIODevice::readAll() (196x)
  2,637 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
  1,383 ( 0.00%)      QJsonDocument doc = QJsonDocument::fromJson(data);
85,200,370 (39.82%)  => ???:QJsonDocument::fromJson(QByteArray const&, QJsonParseError*) (196x)
444,940 ( 0.21%)  => ???:0x0000000000012dc0'2 (1x)
  1,186 ( 0.00%)      if (doc.isObject()) {
  1,076 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
  1,372 ( 0.00%)  => ???:QJsonDocument::isObject() const (196x)
  1,186 ( 0.00%)          QJsonObject obj = doc.object();
  1,052 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
  2,548 ( 0.00%)  => ???:QJsonDocument::object() const (196x)
    591 ( 0.00%)          std::vector<std::vector<Fusion::PixelData>> mock_values;
  9,456 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::vector() (197x)
  6,911 ( 0.00%)          mock_values.reserve(obj["values"].toArray().size());
123,872 ( 0.06%)  => ???:QJsonObject::operator[](QString const&) (196x)
 73,434 ( 0.03%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (197x)
 42,500 ( 0.02%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (197x)
  1,372 ( 0.00%)  => ???:QJsonArray::~QJsonArray() (196x)
  4,832 ( 0.00%)  => ???:0x0000000000012dc0'2 (4x)
 20,384 ( 0.01%)  => ???:QJsonValueRef::toArray() const (196x)
 68,753 ( 0.03%)  => /usr/include/c++/15.1.1/bits/vector.tcc:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::reserve(unsigned long) (197x)
  1,372 ( 0.00%)  => ???:QJsonArray::size() const (196x)
  4,334 ( 0.00%)          QJsonArray valuesArray = obj["values"].toArray();
124,504 ( 0.06%)  => ???:QJsonObject::operator[](QString const&) (197x)
 72,299 ( 0.03%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (197x)
 41,370 ( 0.02%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (197x)
 20,488 ( 0.01%)  => ???:QJsonValueRef::toArray() const (197x)
  6,316 ( 0.00%)          qint64 timestamp = obj["timestamp"].toVariant().toLongLong();
102,637 ( 0.05%)  => ???:QJsonObject::operator[](QString const&) (197x)
 70,920 ( 0.03%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (197x)
 41,370 ( 0.02%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (197x)
  3,190 ( 0.00%)  => ???:0x0000000000012dc0'2 (3x)
 22,148 ( 0.01%)  => ???:QJsonValueRef::toVariant() const (196x)
  6,860 ( 0.00%)  => ???:QVariant::toLongLong(bool*) const (196x)
  3,332 ( 0.00%)  => ???:QVariant::~QVariant() (196x)
 38,612 ( 0.02%)          for (const QJsonValue &value : valuesArray) {
152,393 ( 0.07%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::operator QJsonValue() const (1,576x)
121,135 ( 0.06%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::begin() (197x)
 83,528 ( 0.04%)  => /usr/include/qt6/QtCore/qjsonarray.h:operator!=(QJsonArray::iterator const&, QJsonArray::iterator const&) (1,773x)
 28,368 ( 0.01%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator++() (1,576x)
 22,261 ( 0.01%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::end() (197x)
 12,608 ( 0.01%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator*() const (1,576x)
  9,460 ( 0.00%)              QJsonObject valueObj = value.toObject();
  1,051 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
 18,900 ( 0.01%)  => ???:QJsonValue::toObject() const (1,575x)
  4,728 ( 0.00%)              std::vector<Fusion::PixelData> pixelDataList;
 75,648 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::vector() (1,576x)
 55,160 ( 0.03%)              pixelDataList.reserve(valueObj["pixels"].toArray().size());
770,664 ( 0.36%)  => ???:QJsonObject::operator[](QString const&) (1,576x)
578,392 ( 0.27%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (1,576x)
330,960 ( 0.15%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (1,576x)
566,452 ( 0.26%)  => /usr/include/c++/15.1.1/bits/vector.tcc:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::reserve(unsigned long) (1,576x)
 11,032 ( 0.01%)  => ???:QJsonArray::~QJsonArray() (1,576x)
163,904 ( 0.08%)  => ???:QJsonValueRef::toArray() const (1,576x)
 11,032 ( 0.01%)  => ???:QJsonArray::size() const (1,576x)
 34,672 ( 0.02%)              QJsonArray pixelsArray = valueObj["pixels"].toArray();
770,664 ( 0.36%)  => ???:QJsonObject::operator[](QString const&) (1,576x)
578,392 ( 0.27%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (1,576x)
330,960 ( 0.15%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (1,576x)
163,904 ( 0.08%)  => ???:QJsonValueRef::toArray() const (1,576x)
290,856 ( 0.14%)              for (const QJsonValue &pixelValue : pixelsArray) {
1,131,648 ( 0.53%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::operator QJsonValue() const (11,788x)
985,254 ( 0.46%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::begin() (1,576x)
629,684 ( 0.29%)  => /usr/include/qt6/QtCore/qjsonarray.h:operator!=(QJsonArray::iterator const&, QJsonArray::iterator const&) (13,364x)
212,184 ( 0.10%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator++() (11,788x)
178,088 ( 0.08%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::end() (1,576x)
 94,304 ( 0.04%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator*() const (11,788x)
 70,728 ( 0.03%)                  QJsonObject pixelObj = pixelValue.toObject();
141,456 ( 0.07%)  => ???:QJsonValue::toObject() const (11,788x)
      .                           Fusion::PixelData pixelData;
271,124 ( 0.13%)                  pixelData.pixel_depth = pixelObj["pixel_depth"].toDouble();
8,723,120 ( 4.08%)  => ???:QJsonObject::operator[](QString const&) (11,788x)
4,408,712 ( 2.06%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (11,788x)
2,475,480 ( 1.16%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (11,788x)
508,398 ( 0.24%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::toDouble(double) const (11,788x)
271,124 ( 0.13%)                  pixelData.pixel_pos_x = pixelObj["pixel_pos_x"].toDouble();
8,734,908 ( 4.08%)  => ???:QJsonObject::operator[](QString const&) (11,788x)
4,408,712 ( 2.06%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (11,788x)
2,475,480 ( 1.16%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (11,788x)
507,241 ( 0.24%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::toDouble(double) const (11,788x)
271,124 ( 0.13%)                  pixelData.pixel_pos_y = pixelObj["pixel_pos_y"].toDouble();
10,043,376 ( 4.69%)  => ???:QJsonObject::operator[](QString const&) (11,788x)
4,408,712 ( 2.06%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (11,788x)
2,475,480 ( 1.16%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (11,788x)
507,274 ( 0.24%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::toDouble(double) const (11,788x)
 58,940 ( 0.03%)                  pixelDataList.push_back(pixelData);
707,280 ( 0.33%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::push_back(Fusion::PixelData const&) (11,788x)
 94,312 ( 0.04%)              }
  1,944 ( 0.00%)  => ???:0x0000000000012dc0'2 (2x)
153,231 ( 0.07%)  => ???:QJsonValue::~QJsonValue() (11,787x)
 82,509 ( 0.04%)  => ???:QJsonObject::~QJsonObject() (11,787x)
  7,880 ( 0.00%)              mock_values.push_back(pixelDataList);
875,833 ( 0.41%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::push_back(std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > const&) (1,576x)
 23,640 ( 0.01%)          }
426,306 ( 0.20%)  => ???:QJsonArray::~QJsonArray() (1,576x)
300,366 ( 0.14%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >::~vector() (1,576x)
 20,488 ( 0.01%)  => ???:QJsonValue::~QJsonValue() (1,576x)
 11,032 ( 0.01%)  => ???:QJsonObject::~QJsonObject() (1,576x)
    591 ( 0.00%)          QList<uint> radarValues;
 50,038 ( 0.02%)          for (const QJsonValue &val : obj["radarData"].toArray())
102,440 ( 0.05%)  => ???:QJsonObject::operator[](QString const&) (197x)
 70,920 ( 0.03%)  => /usr/include/qt6/QtCore/qstring.h:QString::QString(char const*) (197x)
 41,370 ( 0.02%)  => /usr/include/qt6/QtCore/qstring.h:QString::~QString() (197x)
129,232 ( 0.06%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueRef::operator QJsonValue() const (1,576x)
116,965 ( 0.05%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::begin() (197x)
 83,528 ( 0.04%)  => /usr/include/qt6/QtCore/qjsonarray.h:operator!=(QJsonArray::iterator const&, QJsonArray::iterator const&) (1,773x)
 44,916 ( 0.02%)  => ???:QJsonArray::~QJsonArray() (197x)
 20,488 ( 0.01%)  => ???:QJsonValueRef::toArray() const (197x)
 28,368 ( 0.01%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator++() (1,576x)
 22,261 ( 0.01%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::end() (197x)
 17,336 ( 0.01%)  => ???:QJsonValue::~QJsonValue() (1,576x)
 12,608 ( 0.01%)  => /usr/include/qt6/QtCore/qjsonarray.h:QJsonArray::iterator::operator*() const (1,576x)
 15,764 ( 0.01%)              radarValues.append(val.toInt());
1,219,347 ( 0.57%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::append(unsigned int) (1,576x)
  1,038 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
 15,750 ( 0.01%)  => ???:QJsonValue::toInt(int) const (1,575x)
      .                   Buffer::RadarData r;
  1,182 ( 0.00%)          r.a = radarValues[0];
 29,353 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::operator[](long long) (197x)
  1,182 ( 0.00%)          r.b = radarValues[1];
 29,353 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::operator[](long long) (197x)
  1,182 ( 0.00%)          r.c = radarValues[2];
 29,353 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::operator[](long long) (197x)
  1,182 ( 0.00%)          r.d = radarValues[3];
 29,353 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::operator[](long long) (197x)
  1,182 ( 0.00%)          r.e = radarValues[4];
 29,353 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::operator[](long long) (197x)
  1,182 ( 0.00%)          r.f = radarValues[5];
 29,353 ( 0.01%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::operator[](long long) (197x)
    394 ( 0.00%)          r.timestamp = timestamp;
  2,758 ( 0.00%)          emit dataReceived(mock_values, r);
18,595,599 ( 8.69%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/moc_erfanmocker.cpp:ErfanMocker::dataReceived(std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > > const&, Buffer::RadarData) (197x)
  2,758 ( 0.00%)      }
 54,372 ( 0.03%)  => ???:QJsonArray::~QJsonArray() (197x)
372,085 ( 0.17%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > >::~vector() (197x)
  1,379 ( 0.00%)  => ???:QJsonObject::~QJsonObject() (197x)
 41,473 ( 0.02%)  => /usr/include/qt6/QtCore/qlist.h:QList<unsigned int>::~QList() (197x)
  2,565 ( 0.00%)  }
7,438,555 ( 3.48%)  => ???:QJsonDocument::~QJsonDocument() (196x)
 41,593 ( 0.02%)  => ???:0x0000000000012dc0'2 (1x)
 56,933 ( 0.03%)  => /usr/include/qt6/QtCore/qbytearray.h:QByteArray::~QByteArray() (197x)
      .           

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/stl_iterator.h
--------------------------------------------------------------------------------
Ir               

-- line 1051 ----------------------------------------
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX_CONSTEXPR
      .                 __normal_iterator() _GLIBCXX_NOEXCEPT
      .                 : _M_current() { }
      .           
      .                 __attribute__((__always_inline__))
      .                 explicit _GLIBCXX_CONSTEXPR
      .                 __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
 35,449 ( 0.02%)        : _M_current(__i) { }
      .           
      .                 // Allow iterator to const_iterator conversion
      .           #if __cplusplus >= 201103L
      .           # ifdef __glibcxx_concepts
      .                 template<typename _Iter> requires std::is_convertible_v<_Iter, _Iterator>
      .           # else
      .                 template<typename _Iter, typename = __convertible_from<_Iter>>
      .           # endif
-- line 1067 ----------------------------------------
-- line 1082 ----------------------------------------
      .                   : _M_current(__i.base()) { }
      .           
      .                 // Forward iterator requirements
      .           
      .                 _GLIBCXX_NODISCARD __attribute__((__always_inline__))
      .                 _GLIBCXX_CONSTEXPR
      .                 reference
      .                 operator*() const _GLIBCXX_NOEXCEPT
 19,274 ( 0.01%)        { return *_M_current; }
      .           
      .                 _GLIBCXX_NODISCARD __attribute__((__always_inline__))
      .                 _GLIBCXX_CONSTEXPR
      .                 pointer
      .                 operator->() const _GLIBCXX_NOEXCEPT
      .                 { return _M_current; }
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX14_CONSTEXPR
      .                 __normal_iterator&
      .                 operator++() _GLIBCXX_NOEXCEPT
      .                 {
 44,229 ( 0.02%)  	++_M_current;
 48,563 ( 0.02%)  	return *this;
      .                 }
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX14_CONSTEXPR
      .                 __normal_iterator
      .                 operator++(int) _GLIBCXX_NOEXCEPT
      .                 { return __normal_iterator(_M_current++); }
      .           
      .                 // Bidirectional iterator requirements
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX14_CONSTEXPR
      .                 __normal_iterator&
      .                 operator--() _GLIBCXX_NOEXCEPT
      .                 {
  2,364 ( 0.00%)  	--_M_current;
      .           	return *this;
      .                 }
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX14_CONSTEXPR
      .                 __normal_iterator
      .                 operator--(int) _GLIBCXX_NOEXCEPT
      .                 { return __normal_iterator(_M_current--); }
-- line 1128 ----------------------------------------
-- line 1134 ----------------------------------------
      .                 reference
      .                 operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
      .                 { return _M_current[__n]; }
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX14_CONSTEXPR
      .                 __normal_iterator&
      .                 operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
    788 ( 0.00%)        { _M_current += __n; return *this; }
      .           
      .                 _GLIBCXX_NODISCARD __attribute__((__always_inline__))
      .                 _GLIBCXX_CONSTEXPR
      .                 __normal_iterator
      .                 operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
  4,919 ( 0.00%)        { return __normal_iterator(_M_current + __n); }
      .           
      .                 __attribute__((__always_inline__))
      .                 _GLIBCXX14_CONSTEXPR
      .                 __normal_iterator&
      .                 operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
      .                 { _M_current -= __n; return *this; }
      .           
      .                 _GLIBCXX_NODISCARD __attribute__((__always_inline__))
-- line 1156 ----------------------------------------
-- line 1158 ----------------------------------------
      .                 __normal_iterator
      .                 operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
      .                 { return __normal_iterator(_M_current - __n); }
      .           
      .                 _GLIBCXX_NODISCARD __attribute__((__always_inline__))
      .                 _GLIBCXX_CONSTEXPR
      .                 const _Iterator&
      .                 base() const _GLIBCXX_NOEXCEPT
 44,260 ( 0.02%)        { return _M_current; }
      .               };
      .           
      .             // Note: In what follows, the left- and right-hand-side iterators are
      .             // allowed to vary in types (conceptually in cv-qualification) so that
      .             // comparison between cv-qualified and non-cv-qualified iterators be
      .             // valid.  However, the greedy and unfriendly operators in std::rel_ops
      .             // will make overload resolution ambiguous (when in scope) if we don't
      .             // provide overloads whose operands are of the same type.  Can someone
-- line 1174 ----------------------------------------
-- line 1223 ----------------------------------------
      .               { return __lhs.base() == __rhs.base(); }
      .           
      .             template<typename _Iterator, typename _Container>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__)) _GLIBCXX_CONSTEXPR
      .               inline bool
      .               operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
      .           	       const __normal_iterator<_Iterator, _Container>& __rhs)
      .               _GLIBCXX_NOEXCEPT
  3,546 ( 0.00%)      { return __lhs.base() == __rhs.base(); }
      .           
      .             template<typename _IteratorL, typename _IteratorR, typename _Container>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__)) _GLIBCXX_CONSTEXPR
      .               inline bool
      .               operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .           	       const __normal_iterator<_IteratorR, _Container>& __rhs)
      .               _GLIBCXX_NOEXCEPT
      .               { return __lhs.base() != __rhs.base(); }
      .           
      .             template<typename _Iterator, typename _Container>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__)) _GLIBCXX_CONSTEXPR
      .               inline bool
      .               operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
      .           	       const __normal_iterator<_Iterator, _Container>& __rhs)
      .               _GLIBCXX_NOEXCEPT
101,460 ( 0.05%)      { return __lhs.base() != __rhs.base(); }
      .           
      .             // Random access iterator requirements
      .             template<typename _IteratorL, typename _IteratorR, typename _Container>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__)) _GLIBCXX_CONSTEXPR
      .               inline bool
      .               operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
      .           	      const __normal_iterator<_IteratorR, _Container>& __rhs)
      .               _GLIBCXX_NOEXCEPT
-- line 1255 ----------------------------------------
-- line 1332 ----------------------------------------
      .               { return __lhs.base() - __rhs.base(); }
      .           
      .             template<typename _Iterator, typename _Container>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__)) _GLIBCXX_CONSTEXPR
      .               inline typename __normal_iterator<_Iterator, _Container>::difference_type
      .               operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
      .           	      const __normal_iterator<_Iterator, _Container>& __rhs)
      .               _GLIBCXX_NOEXCEPT
 24,435 ( 0.01%)      { return __lhs.base() - __rhs.base(); }
      .           
      .             template<typename _Iterator, typename _Container>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__)) _GLIBCXX_CONSTEXPR
      .               inline __normal_iterator<_Iterator, _Container>
      .               operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
      .           	      __n, const __normal_iterator<_Iterator, _Container>& __i)
      .               _GLIBCXX_NOEXCEPT
      .               { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
-- line 1348 ----------------------------------------
-- line 2994 ----------------------------------------
      .             // Unwrap a __normal_iterator to get the underlying iterator
      .             // (usually a pointer). See uses in std::copy, std::fill, etc.
      .             template<typename _Iterator, typename _Container>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__))
      .               _GLIBCXX20_CONSTEXPR
      .               inline _Iterator
      .               __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
      .               _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
  8,857 ( 0.00%)      { return __it.base(); }
      .           
      .             // Fallback implementation used for iterators that can't be unwrapped.
      .             template<typename _Iterator>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__))
      .               _GLIBCXX20_CONSTEXPR
      .               inline _Iterator
      .               __niter_base(_Iterator __it)
      .               _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
 15,371 ( 0.01%)      { return __it; }
      .           
      .             // Overload for _Safe_iterator needs to be declared before uses of
      .             // std::__niter_base because we call it qualified so isn't found by ADL.
      .           #if __cplusplus < 201103L
      .             template<typename _Ite, typename _Seq>
      .               _Ite
      .               __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
      .           		 std::random_access_iterator_tag>&);
-- line 3019 ----------------------------------------
-- line 3065 ----------------------------------------
      .             // Reverse the __niter_base transformation to get a __normal_iterator
      .             // back again (this assumes that __normal_iterator is only used to wrap
      .             // random access iterators, like pointers).
      .             // All overloads of std::__niter_base must be declared before this.
      .             template<typename _From, typename _To>
      .               _GLIBCXX_NODISCARD
      .               _GLIBCXX20_CONSTEXPR
      .               inline _From
  1,960 ( 0.00%)      __niter_wrap(_From __from, _To __res)
  1,764 ( 0.00%)      { return __from + (std::__niter_base(__res) - std::__niter_base(__from)); }
      .           
      .             // No need to wrap, iterator already has the right type.
      .             template<typename _Iterator>
      .               _GLIBCXX_NODISCARD __attribute__((__always_inline__))
      .               _GLIBCXX20_CONSTEXPR
      .               inline _Iterator
      .               __niter_wrap(const _Iterator&, _Iterator __res)
    197 ( 0.00%)      { return __res; }
      .           
      .             /// @endcond
      .           
      .           #if __cpp_deduction_guides >= 201606
      .             // These helper traits are used for deduction guides
      .             // of associative containers.
      .             template<typename _InputIterator>
      .               using __iter_key_t = remove_const_t<
-- line 3090 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/stl_algo.h
--------------------------------------------------------------------------------
Ir             

-- line 1743 ----------------------------------------
    .               }
    .           
    .             /// @cond undocumented
    .           
    .             /// This is a helper function for the sort routine.
    .             template<typename _RandomAccessIterator, typename _Compare>
    .               _GLIBCXX20_CONSTEXPR
    .               void
5,516 ( 0.00%)      __unguarded_linear_insert(_RandomAccessIterator __last,
    .           			      _Compare __comp)
    .               {
    .                 typename iterator_traits<_RandomAccessIterator>::value_type
3,152 ( 0.00%)  	__val = _GLIBCXX_MOVE(*__last);
1,576 ( 0.00%)        _RandomAccessIterator __next = __last;
    .                 --__next;
7,092 ( 0.00%)        while (__comp(__val, __next))
21,276 ( 0.01%)  => /usr/include/c++/15.1.1/bits/predefined_ops.h:bool __gnu_cxx::__ops::_Val_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>::operator()<Fusion::RadarData, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > >(Fusion::RadarData&, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >) (788x)
    .           	{
    .           	  *__last = _GLIBCXX_MOVE(*__next);
    .           	  __last = __next;
    .           	  --__next;
    .           	}
3,152 ( 0.00%)        *__last = _GLIBCXX_MOVE(__val);
4,728 ( 0.00%)      }
    .           
    .             /// This is a helper function for the sort routine.
    .             template<typename _RandomAccessIterator, typename _Compare>
    .               _GLIBCXX20_CONSTEXPR
    .               void
4,334 ( 0.00%)      __insertion_sort(_RandomAccessIterator __first,
    .           		     _RandomAccessIterator __last, _Compare __comp)
    .               {
1,182 ( 0.00%)        if (__first == __last) return;
    .           
3,546 ( 0.00%)        for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
    .           	{
6,304 ( 0.00%)  	  if (__comp(__i, __first))
21,276 ( 0.01%)  => /usr/include/c++/15.1.1/bits/predefined_ops.h:bool __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>::operator()<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > > >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >) (788x)
    .           	    {
    .           	      typename iterator_traits<_RandomAccessIterator>::value_type
    .           		__val = _GLIBCXX_MOVE(*__i);
    .           	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
    .           	      *__first = _GLIBCXX_MOVE(__val);
    .           	    }
    .           	  else
3,152 ( 0.00%)  	    std::__unguarded_linear_insert(__i,
52,796 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__unguarded_linear_insert<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Val_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Val_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (788x)
20,488 ( 0.01%)  => /usr/include/c++/15.1.1/bits/predefined_ops.h:__gnu_cxx::__ops::_Val_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> __gnu_cxx::__ops::__val_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>(__gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (788x)
    .           				__gnu_cxx::__ops::__val_comp_iter(__comp));
    .           	}
2,364 ( 0.00%)      }
    .           
    .             /// This is a helper function for the sort routine.
    .             template<typename _RandomAccessIterator, typename _Compare>
    .               _GLIBCXX20_CONSTEXPR
    .               inline void
    .               __unguarded_insertion_sort(_RandomAccessIterator __first,
    .           			       _RandomAccessIterator __last, _Compare __comp)
    .               {
-- line 1797 ----------------------------------------
-- line 2245 ----------------------------------------
    .               }
    .           
    .             // merge
    .           
    .             /// This is a helper function for the __merge_adaptive routines.
    .             template<typename _InputIterator1, typename _InputIterator2,
    .           	   typename _OutputIterator, typename _Compare>
    .               void
1,576 ( 0.00%)      __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
    .           			  _InputIterator2 __first2, _InputIterator2 __last2,
    .           			  _OutputIterator __result, _Compare __comp)
    .               {
7,880 ( 0.00%)        while (__first1 != __last1 && __first2 != __last2)
    .           	{
4,728 ( 0.00%)  	  if (__comp(__first2, __first1))
15,957 ( 0.01%)  => /usr/include/c++/15.1.1/bits/predefined_ops.h:bool __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>::operator()<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*>(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*) (591x)
    .           	    {
    .           	      *__result = _GLIBCXX_MOVE(*__first2);
    .           	      ++__first2;
    .           	    }
    .           	  else
    .           	    {
2,364 ( 0.00%)  	      *__result = _GLIBCXX_MOVE(*__first1);
  591 ( 0.00%)  	      ++__first1;
    .           	    }
    .           	  ++__result;
    .           	}
  591 ( 0.00%)        if (__first1 != __last1)
    .           	_GLIBCXX_MOVE3(__first1, __last1, __result);
  591 ( 0.00%)      }
    .           
    .             /// This is a helper function for the __merge_adaptive routines.
    .             template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    .           	   typename _BidirectionalIterator3, typename _Compare>
    .               void
    .               __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
    .           				   _BidirectionalIterator1 __last1,
    .           				   _BidirectionalIterator2 __first2,
-- line 2281 ----------------------------------------
-- line 2352 ----------------------------------------
    .                 else
    .           	return std::rotate(__first, __middle, __last);
    .               }
    .           
    .             /// This is a helper function for the merge routines.
    .             template<typename _BidirectionalIterator, typename _Distance,
    .           	   typename _Pointer, typename _Compare>
    .               void
1,773 ( 0.00%)      __merge_adaptive(_BidirectionalIterator __first,
    .           		     _BidirectionalIterator __middle,
    .           		     _BidirectionalIterator __last,
    .           		     _Distance __len1, _Distance __len2,
    .           		     _Pointer __buffer, _Compare __comp)
    .               {
  591 ( 0.00%)        if (__len1 <= __len2)
    .           	{
1,379 ( 0.00%)  	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
26,346 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_algobase.h:Fusion::RadarData* std::move<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*>(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*) (197x)
1,576 ( 0.00%)  	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
43,734 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__move_merge_adaptive<Fusion::RadarData*, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(Fusion::RadarData*, Fusion::RadarData*, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (197x)
    .           				     __first, __comp);
    .           	}
    .                 else
    .           	{
    .           	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
    .           	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
    .           					      __buffer_end, __last, __comp);
    .           	}
  788 ( 0.00%)      }
    .           
    .             template<typename _BidirectionalIterator, typename _Distance,
    .           	   typename _Pointer, typename _Compare>
    .               void
    .               __merge_adaptive_resize(_BidirectionalIterator __first,
    .           			    _BidirectionalIterator __middle,
    .           			    _BidirectionalIterator __last,
    .           			    _Distance __len1, _Distance __len2,
-- line 2386 ----------------------------------------
-- line 2661 ----------------------------------------
    .                 std::__move_merge(__first, __first + __step_size,
    .           			__first + __step_size, __last, __result, __comp);
    .               }
    .           
    .             template<typename _RandomAccessIterator, typename _Distance,
    .           	   typename _Compare>
    .               _GLIBCXX20_CONSTEXPR
    .               void
3,546 ( 0.00%)      __chunk_insertion_sort(_RandomAccessIterator __first,
    .           			   _RandomAccessIterator __last,
    .           			   _Distance __chunk_size, _Compare __comp)
    .               {
1,970 ( 0.00%)        while (__last - __first >= __chunk_size)
    .           	{
    .           	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
    .           	  __first += __chunk_size;
    .           	}
1,970 ( 0.00%)        std::__insertion_sort(__first, __last, __comp);
137,112 ( 0.06%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__insertion_sort<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (394x)
2,364 ( 0.00%)      }
    .           
    .             enum { _S_chunk_size = 7 };
    .           
    .             template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    .               void
3,152 ( 0.00%)      __merge_sort_with_buffer(_RandomAccessIterator __first,
    .           			     _RandomAccessIterator __last,
    .           			     _Pointer __buffer, _Compare __comp)
    .               {
    .                 typedef typename iterator_traits<_RandomAccessIterator>::difference_type
    .           	_Distance;
    .           
  394 ( 0.00%)        const _Distance __len = __last - __first;
2,364 ( 0.00%)        const _Pointer __buffer_last = __buffer + __len;
    .           
  394 ( 0.00%)        _Distance __step_size = _S_chunk_size;
2,364 ( 0.00%)        std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
151,296 ( 0.07%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__chunk_insertion_sort<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, long, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, long, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (394x)
    .           
1,576 ( 0.00%)        while (__step_size < __len)
    .           	{
    .           	  std::__merge_sort_loop(__first, __last, __buffer,
    .           				 __step_size, __comp);
    .           	  __step_size *= 2;
    .           	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
    .           				 __step_size, __comp);
    .           	  __step_size *= 2;
    .           	}
1,576 ( 0.00%)      }
    .           
    .             template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    .               void
1,379 ( 0.00%)      __stable_sort_adaptive(_RandomAccessIterator __first,
    .           			   _RandomAccessIterator __middle,
    .           			   _RandomAccessIterator __last,
    .           			   _Pointer __buffer, _Compare __comp)
    .               {
1,182 ( 0.00%)        std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
83,331 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__merge_sort_with_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (197x)
1,576 ( 0.00%)        std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
83,331 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__merge_sort_with_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (197x)
    .           
1,576 ( 0.00%)        std::__merge_adaptive(__first, __middle, __last,
76,187 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__merge_adaptive<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, long, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, long, long, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (197x)
    .           			    __middle - __first, __last - __middle,
    .           			    __buffer, __comp);
  591 ( 0.00%)      }
    .           
    .             template<typename _RandomAccessIterator, typename _Pointer,
    .           	   typename _Distance, typename _Compare>
    .               void
    .               __stable_sort_adaptive_resize(_RandomAccessIterator __first,
    .           				  _RandomAccessIterator __last,
    .           				  _Pointer __buffer, _Distance __buffer_size,
    .           				  _Compare __comp)
-- line 2730 ----------------------------------------
-- line 4996 ----------------------------------------
    .                 return _GLIBCXX_STD_A::__merge(__first1, __last1,
    .           				__first2, __last2, __result,
    .           				__gnu_cxx::__ops::__iter_comp_iter(__comp));
    .               }
    .           
    .             template<typename _RandomAccessIterator, typename _Compare>
    .               _GLIBCXX26_CONSTEXPR
    .               inline void
2,167 ( 0.00%)      __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    .           		  _Compare __comp)
    .               {
    .                 typedef typename iterator_traits<_RandomAccessIterator>::value_type
    .           	_ValueType;
    .                 typedef typename iterator_traits<_RandomAccessIterator>::difference_type
    .           	_DistanceType;
    .           
  394 ( 0.00%)        if (__first == __last)
    .           	return;
    .           
    .           #if _GLIBCXX_HOSTED
    .           # if __glibcxx_constexpr_algorithms >= 202306L // >= C++26
    .                 if consteval {
    .           	return std::__inplace_stable_sort(__first, __last, __comp);
    .                 }
    .           # endif
    .           
    .                 typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
    .                 // __stable_sort_adaptive sorts the range in two halves,
    .                 // so the buffer only needs to fit half the range at once.
2,167 ( 0.00%)        _TmpBuf __buf(__first, (__last - __first + 1) / 2);
48,469 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_tempbuf.h:std::_Temporary_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData>::_Temporary_buffer(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, long) (197x)
    .           
2,758 ( 0.00%)        if (__builtin_expect(__buf.requested_size() == __buf.size(), true))
1,379 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_tempbuf.h:std::_Temporary_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData>::size() const (197x)
1,379 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_tempbuf.h:std::_Temporary_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData>::requested_size() const (197x)
1,970 ( 0.00%)  	std::__stable_sort_adaptive(__first,
253,487 ( 0.12%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__stable_sort_adaptive<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData*, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (197x)
1,379 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_tempbuf.h:std::_Temporary_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData>::begin() (197x)
  788 ( 0.00%)  				    __first + _DistanceType(__buf.size()),
1,379 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_tempbuf.h:std::_Temporary_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData>::size() const (197x)
    .           				    __last, __buf.begin(), __comp);
    .                 else if (__builtin_expect(__buf.begin() == 0, false))
    .           	std::__inplace_stable_sort(__first, __last, __comp);
    .                 else
    .           	std::__stable_sort_adaptive_resize(__first, __last, __buf.begin(),
    .           					   _DistanceType(__buf.size()), __comp);
    .           #else
    .                 std::__inplace_stable_sort(__first, __last, __comp);
    .           #endif
2,364 ( 0.00%)      }
24,231 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_tempbuf.h:std::_Temporary_buffer<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, Fusion::RadarData>::~_Temporary_buffer() (197x)
    .           
    .             /**
    .              *  @brief Sort the elements of a sequence, preserving the relative order
    .              *         of equivalent elements.
    .              *  @ingroup sorting_algorithms
    .              *  @param  __first   An iterator.
    .              *  @param  __last    Another iterator.
    .              *  @return  Nothing.
-- line 5047 ----------------------------------------
-- line 5088 ----------------------------------------
    .              *  The relative ordering of equivalent elements is preserved, so any two
    .              *  elements @p x and @p y in the range @p [__first,__last) such that
    .              *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
    .              *  relative ordering after calling @p stable_sort().
    .             */
    .             template<typename _RandomAccessIterator, typename _Compare>
    .               _GLIBCXX26_CONSTEXPR
    .               inline void
  985 ( 0.00%)      stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    .           		_Compare __comp)
    .               {
    .                 // concept requirements
    .                 __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
    .           	    _RandomAccessIterator>)
    .                 __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
    .           	    typename iterator_traits<_RandomAccessIterator>::value_type,
    .           	    typename iterator_traits<_RandomAccessIterator>::value_type>)
    .                 __glibcxx_requires_valid_range(__first, __last);
    .                 __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
    .           
1,182 ( 0.00%)        _GLIBCXX_STD_A::__stable_sort(__first, __last,
349,630 ( 0.16%)  => /usr/include/c++/15.1.1/bits/stl_algo.h:void std::__stable_sort<__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> >(__gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__normal_iterator<Fusion::RadarData*, std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > >, __gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>) (197x)
4,137 ( 0.00%)  => /usr/include/c++/15.1.1/bits/predefined_ops.h:__gnu_cxx::__ops::_Iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}> __gnu_cxx::__ops::__iter_comp_iter<Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}>(Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&)::{lambda(Fusion::RadarData const&, Fusion::RadarData const&)#1}) (197x)
    .           				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
  591 ( 0.00%)      }
    .           
    .             template<typename _InputIterator1, typename _InputIterator2,
    .           	   typename _OutputIterator,
    .           	   typename _Compare>
    .               _GLIBCXX20_CONSTEXPR
    .               _OutputIterator
    .               __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
    .           		_InputIterator2 __first2, _InputIterator2 __last2,
-- line 5118 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qarraydatapointer.h
--------------------------------------------------------------------------------
Ir               

-- line 23 ----------------------------------------
      .               enum {
      .                   pass_parameter_by_value =
      .                           std::is_arithmetic<T>::value || std::is_pointer<T>::value || std::is_enum<T>::value
      .               };
      .           
      .               typedef typename std::conditional<pass_parameter_by_value, T, const T &>::type parameter_type;
      .           
      .               Q_NODISCARD_CTOR
      6 ( 0.00%)      constexpr QArrayDataPointer() noexcept
     12 ( 0.00%)          : d(nullptr), ptr(nullptr), size(0)
      .               {
      6 ( 0.00%)      }
      .           
      .               Q_NODISCARD_CTOR
      .               QArrayDataPointer(const QArrayDataPointer &other) noexcept
      .                   : d(other.d), ptr(other.ptr), size(other.size)
      .               {
      .                   ref();
      .               }
      .           
      .               Q_NODISCARD_CTOR
  1,230 ( 0.00%)      constexpr QArrayDataPointer(Data *header, T *adata, qsizetype n = 0) noexcept
  1,845 ( 0.00%)          : d(header), ptr(adata), size(n)
      .               {
    615 ( 0.00%)      }
      .           
      .               Q_NODISCARD_CTOR
      .               explicit QArrayDataPointer(std::pair<QTypedArrayData<T> *, T *> adata, qsizetype n = 0) noexcept
      .                   : d(adata.first), ptr(adata.second), size(n)
      .               {
      .               }
      .           
      .               Q_NODISCARD_CTOR explicit
-- line 55 ----------------------------------------
-- line 83 ----------------------------------------
      .           
      .               QT_MOVE_ASSIGNMENT_OPERATOR_IMPL_VIA_MOVE_AND_SWAP(QArrayDataPointer)
      .           
      .               DataOps &operator*() noexcept
      .               {
      .                   return *static_cast<DataOps *>(this);
      .               }
      .           
142,776 ( 0.07%)      DataOps *operator->() noexcept
      .               {
 47,592 ( 0.02%)          return static_cast<DataOps *>(this);
 95,184 ( 0.04%)      }
      .           
      .               const DataOps &operator*() const noexcept
      .               {
      .                   return *static_cast<const DataOps *>(this);
      .               }
      .           
      .               const DataOps *operator->() const noexcept
      .               {
      .                   return static_cast<const DataOps *>(this);
      .               }
      .           
159,612 ( 0.07%)      ~QArrayDataPointer()
      .               {
239,418 ( 0.11%)          if (!deref()) {
 12,411 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::deref() (394x)
198,525 ( 0.09%)              (*this)->destroyAll();
 11,820 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QPodArrayOps<unsigned int>::destroyAll() (197x)
  1,182 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::operator->() (197x)
198,529 ( 0.09%)              free(d);
 11,923 ( 0.01%)  => ???:free (197x)
      .                   }
119,709 ( 0.06%)      }
      .           
      .               bool isNull() const noexcept
      .               {
      .                   return !ptr;
      .               }
      .           
 31,962 ( 0.01%)      T *data() noexcept { return ptr; }
      .               const T *data() const noexcept { return ptr; }
      .           
    252 ( 0.00%)      T *begin() noexcept { return data(); }
    196 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::data() (28x)
 42,928 ( 0.02%)      T *end() noexcept { return data() + size; }
  2,751 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::data() (393x)
      .               const T *begin() const noexcept { return data(); }
      .               const T *end() const noexcept { return data() + size; }
      .               const T *constBegin() const noexcept { return data(); }
      .               const T *constEnd() const noexcept { return data() + size; }
      .           
  1,025 ( 0.00%)      void swap(QArrayDataPointer &other) noexcept
      .               {
  1,025 ( 0.00%)          qt_ptr_swap(d, other.d);
    136 ( 0.00%)  => /usr/include/qt6/QtCore/qswap.h:void qt_ptr_swap<QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > > >(QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*&, QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*&) (8x)
  1,435 ( 0.00%)          qt_ptr_swap(ptr, other.ptr);
    136 ( 0.00%)  => /usr/include/qt6/QtCore/qswap.h:void qt_ptr_swap<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*&, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*&) (8x)
  1,435 ( 0.00%)          std::swap(size, other.size);
    232 ( 0.00%)  => /usr/include/c++/15.1.1/bits/move.h:std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<long long> >, std::is_move_constructible<long long>, std::is_move_assignable<long long> >::value, void>::type std::swap<long long>(long long&, long long&) (8x)
    615 ( 0.00%)      }
      .           
      .               void clear() noexcept(std::is_nothrow_destructible<T>::value)
      .               {
      .                   QArrayDataPointer tmp;
      .                   swap(tmp);
      .               }
      .           
 14,775 ( 0.01%)      void detach(QArrayDataPointer *old = nullptr)
      .               {
 14,775 ( 0.01%)          if (needsDetach())
 13,987 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::needsDetach() const (197x)
      .                       reallocateAndGrow(QArrayData::GrowsAtEnd, 0, old);
  8,865 ( 0.00%)      }
      .           
      .               /*! \internal
      .           
      .                   Reinterprets the data of this QArrayDataPointer to type X. It's the
      .                   caller's responsibility to ensure that the data contents are valid and
      .                   properly aligned, particularly if T and X are not trivial types (i.e,
      .                   don't do that). The current size is kept and the allocated capacity is
      .                   updated to account for the difference in the element type's size.
-- line 154 ----------------------------------------
-- line 185 ----------------------------------------
      .                   QList<T> list(5);
      .                   qsizetype pos = getArbitraryPos();
      .                   list.insert(pos, list.begin(), list.end());
      .                   \endcode
      .           
      .                   The default rule would be: \a data and \a old must either both be valid
      .                   pointers, or both equal to \c nullptr.
      .               */
  3,216 ( 0.00%)      void detachAndGrow(QArrayData::GrowthPosition where, qsizetype n, const T **data,
      .                                  QArrayDataPointer *old)
      .               {
  1,608 ( 0.00%)          const bool detach = needsDetach();
 16,351 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::needsDetach() const (394x)
    402 ( 0.00%)          bool readjusted = false;
  1,608 ( 0.00%)          if (!detach) {
    816 ( 0.00%)              if (!n || (where == QArrayData::GrowsAtBeginning && freeSpaceAtBegin() >= n)
  2,040 ( 0.00%)                  || (where == QArrayData::GrowsAtEnd && freeSpaceAtEnd() >= n))
 15,563 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtEnd() const (197x)
      .                           return;
  1,428 ( 0.00%)              readjusted = tryReadjustFreeSpace(where, n, data);
 68,753 ( 0.03%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::tryReadjustFreeSpace(QArrayData::GrowthPosition, long long, unsigned int const**) (197x)
    816 ( 0.00%)              Q_ASSERT(!readjusted
      .                                || (where == QArrayData::GrowsAtBeginning && freeSpaceAtBegin() >= n)
      .                                || (where == QArrayData::GrowsAtEnd && freeSpaceAtEnd() >= n));
      .                   }
      .           
  1,608 ( 0.00%)          if (!readjusted)
  2,814 ( 0.00%)              reallocateAndGrow(where, n, old);
294,826 ( 0.14%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::reallocateAndGrow(QArrayData::GrowthPosition, long long, QArrayDataPointer<unsigned int>*) (394x)
    804 ( 0.00%)      }
      .           
      .               /*! \internal
      .           
      .                   Reallocates to accommodate the free space for \a n elements at the
      .                   required side. The side is determined from \a pos. Might also shrink
      .                   when n < 0.
      .               */
  4,824 ( 0.00%)      Q_NEVER_INLINE void reallocateAndGrow(QArrayData::GrowthPosition where, qsizetype n,
      .                                                     QArrayDataPointer *old = nullptr)
      .               {
      .                   if constexpr (QTypeInfo<T>::isRelocatable && alignof(T) <= alignof(std::max_align_t)) {
  5,713 ( 0.00%)              if (where == QArrayData::GrowsAtEnd && !old && !needsDetach() && n > 0) {
 16,351 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::needsDetach() const (394x)
  3,743 ( 0.00%)                  (*this)->reallocate(constAllocatedCapacity() - freeSpaceAtEnd() + n, QArrayData::Grow); // fast path
100,916 ( 0.05%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QPodArrayOps<unsigned int>::reallocate(long long, QArrayData::AllocationOption) (197x)
 15,563 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtEnd() const (197x)
  4,334 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::constAllocatedCapacity() const (197x)
  1,182 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::operator->() (197x)
      .                           return;
      .                       }
      .                   }
      .           
  1,230 ( 0.00%)          QArrayDataPointer dp(allocateGrow(*this, n, where));
 92,061 ( 0.04%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::allocateGrow(QArrayDataPointer<unsigned int> const&, long long, QArrayData::GrowthPosition) (197x)
    410 ( 0.00%)          if (n > 0)
  1,435 ( 0.00%)              Q_CHECK_PTR(dp.data());
  1,379 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::data() (197x)
    410 ( 0.00%)          if (where == QArrayData::GrowsAtBeginning) {
      .                       Q_ASSERT(dp.freeSpaceAtBegin() >= n);
      .                   } else {
  1,025 ( 0.00%)              Q_ASSERT(dp.freeSpaceAtEnd() >= n);
 15,563 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtEnd() const (197x)
      .                   }
    820 ( 0.00%)          if (size) {
     21 ( 0.00%)              qsizetype toCopy = size;
     14 ( 0.00%)              if (n < 0)
      .                           toCopy += n;
     70 ( 0.00%)              if (needsDetach() || old)
    497 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::needsDetach() const (7x)
      .                           dp->copyAppend(begin(), begin() + toCopy);
      .                       else
    147 ( 0.00%)                  dp->moveAppend(begin(), begin() + toCopy);
 41,761 ( 0.02%)  => /usr/include/qt6/QtCore/qarraydataops.h:QtPrivate::QGenericArrayOps<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::moveAppend(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*) (7x)
    224 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::begin() (14x)
     42 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::operator->() (7x)
     21 ( 0.00%)              Q_ASSERT(dp.size == toCopy);
      .                   }
      .           
  1,025 ( 0.00%)          swap(dp);
 17,730 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::swap(QArrayDataPointer<unsigned int>&) (197x)
    410 ( 0.00%)          if (old)
      .                       old->swap(dp);
  4,225 ( 0.00%)      }
  4,925 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::~QArrayDataPointer() (197x)
      .           
      .               /*! \internal
      .           
      .                   Attempts to relocate [begin(), end()) to accommodate the free space for
      .                   \a n elements at the required side. The side is determined from \a pos.
      .           
      .                   Returns \c true if the internal data is moved. Returns \c false when
      .                   there is no point in moving the data or the move is impossible. If \c
-- line 258 ----------------------------------------
-- line 261 ----------------------------------------
      .           
      .                   This function expects that certain preconditions are met, e.g. the
      .                   detach is not needed, n > 0 and so on. This is intentional to reduce the
      .                   number of if-statements when the caller knows that preconditions would
      .                   be satisfied.
      .           
      .                   \sa reallocateAndGrow
      .               */
  2,040 ( 0.00%)      bool tryReadjustFreeSpace(QArrayData::GrowthPosition pos, qsizetype n, const T **data = nullptr)
      .               {
  1,224 ( 0.00%)          Q_ASSERT(!this->needsDetach());
    497 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::needsDetach() const (7x)
    408 ( 0.00%)          Q_ASSERT(n > 0);
  1,428 ( 0.00%)          Q_ASSERT((pos == QArrayData::GrowsAtEnd && this->freeSpaceAtEnd() < n)
    560 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::freeSpaceAtEnd() const (7x)
      .                            || (pos == QArrayData::GrowsAtBeginning && this->freeSpaceAtBegin() < n));
      .           
    816 ( 0.00%)          const qsizetype capacity = this->constAllocatedCapacity();
    154 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::constAllocatedCapacity() const (7x)
    816 ( 0.00%)          const qsizetype freeAtBegin = this->freeSpaceAtBegin();
    329 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::freeSpaceAtBegin() const (7x)
    816 ( 0.00%)          const qsizetype freeAtEnd = this->freeSpaceAtEnd();
    560 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::freeSpaceAtEnd() const (7x)
      .           
    204 ( 0.00%)          qsizetype dataStartOffset = 0;
      .                   // algorithm:
      .                   //   a. GrowsAtEnd: relocate if space at begin AND size < (capacity * 2) / 3
      .                   //      [all goes to free space at end]:
      .                   //      new free space at begin = 0
      .                   //
      .                   //   b. GrowsAtBeginning: relocate if space at end AND size < capacity / 3
      .                   //      [balance the free space]:
      .                   //      new free space at begin = n + (total free space - n) / 2
  1,020 ( 0.00%)          if (pos == QArrayData::GrowsAtEnd && freeAtBegin >= n
      .                       && ((3 * this->size) < (2 * capacity))) {
      .                       // dataStartOffset = 0; - done in declaration
    408 ( 0.00%)          } else if (pos == QArrayData::GrowsAtBeginning && freeAtEnd >= n
      .                              && ((3 * this->size) < capacity)) {
      .                       // total free space == capacity - size
      .                       dataStartOffset = n + qMax(0, (capacity - this->size - n) / 2);
      .                   } else {
      .                       // nothing to do otherwise
    408 ( 0.00%)              return false;
      .                   }
      .           
      .                   relocate(dataStartOffset - freeAtBegin, data);
      .           
      .                   Q_ASSERT((pos == QArrayData::GrowsAtEnd && this->freeSpaceAtEnd() >= n)
      .                            || (pos == QArrayData::GrowsAtBeginning && this->freeSpaceAtBegin() >= n));
      .                   return true;
  1,020 ( 0.00%)      }
      .           
      .               /*! \internal
      .           
      .                   Relocates [begin(), end()) by \a offset and updates \a data if it is not
      .                   \c nullptr and points into [begin(), end()).
      .               */
      .               void relocate(qsizetype offset, const T **data = nullptr)
      .               {
-- line 314 ----------------------------------------
-- line 442 ----------------------------------------
      .                   T *const b = this->begin() + this->size;
      .                   T *const e = this->begin() + newSize;
      .                   q17::uninitialized_value_construct(b, e);
      .                   this->size = newSize;
      .               }
      .           
      .               // forwards from QArrayData
      .               qsizetype allocatedCapacity() noexcept { return d ? d->allocatedCapacity() : 0; }
 10,581 ( 0.00%)      qsizetype constAllocatedCapacity() const noexcept { return d ? d->constAllocatedCapacity() : 0; }
    147 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydata.h:QArrayData::constAllocatedCapacity() const (21x)
      .               void ref() noexcept { if (d) d->ref(); }
677,361 ( 0.32%)      bool deref() noexcept { return !d || d->deref(); }
  6,698 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydata.h:QArrayData::deref() (197x)
     63 ( 0.00%)      bool isMutable() const noexcept { return d; } // Returns false if this object is fromRawData()
    119 ( 0.00%)      bool isShared() const noexcept { return !d || d->isShared(); }
    378 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydata.h:QArrayData::isShared() const (7x)
      .               bool isSharedWith(const QArrayDataPointer &other) const noexcept { return d && d == other.d; }
 94,530 ( 0.04%)      bool needsDetach() const noexcept { return !d || d->needsDetach(); }
255,312 ( 0.12%)  => /usr/include/qt6/QtCore/qarraydata.h:QArrayData::needsDetach() (4,728x)
  2,509 ( 0.00%)      qsizetype detachCapacity(qsizetype newSize) const noexcept { return d ? d->detachCapacity(newSize) : newSize; }
    651 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydata.h:QArrayData::detachCapacity(long long) const (7x)
  4,312 ( 0.00%)      const typename Data::ArrayOptions flags() const noexcept { return d ? d->flags : Data::ArrayOptionDefault; }
     36 ( 0.00%)  => /usr/include/qt6/QtCore/qflags.h:QFlags<QArrayData::ArrayOption>::QFlags(QArrayData::ArrayOption) (1x)
      .               void setFlag(typename Data::ArrayOptions f) noexcept { Q_ASSERT(d); d->flags |= f; }
      .               void clearFlag(typename Data::ArrayOptions f) noexcept { if (d) d->flags &= ~f; }
      .           
      .               Data *d_ptr() noexcept { return d; }
      .               void setBegin(T *begin) noexcept { ptr = begin; }
      .           
 17,030 ( 0.01%)      qsizetype freeSpaceAtBegin() const noexcept
      .               {
 13,624 ( 0.01%)          if (d == nullptr)
    396 ( 0.00%)              return 0;
 35,541 ( 0.02%)          return this->ptr - Data::dataStart(d, alignof(typename Data::AlignmentDummy));
 67,965 ( 0.03%)  => /usr/include/qt6/QtCore/qarraydata.h:QTypedArrayData<unsigned int>::dataStart(QArrayData*, long long) (2,955x)
 10,218 ( 0.00%)      }
      .           
 15,975 ( 0.01%)      qsizetype freeSpaceAtEnd() const noexcept
      .               {
 12,780 ( 0.01%)          if (d == nullptr)
    396 ( 0.00%)              return 0;
 38,961 ( 0.02%)          return d->constAllocatedCapacity() - freeSpaceAtBegin() - this->size;
126,868 ( 0.06%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<unsigned int>::freeSpaceAtBegin() const (2,758x)
 19,306 ( 0.01%)  => /usr/include/qt6/QtCore/qarraydata.h:QArrayData::constAllocatedCapacity() const (2,758x)
 12,780 ( 0.01%)      }
      .           
      .               // allocate and grow. Ensure that at the minimum requiredSpace is available at the requested end
  2,255 ( 0.00%)      static QArrayDataPointer allocateGrow(const QArrayDataPointer &from, qsizetype n, QArrayData::GrowthPosition position)
      .               {
      .                   // calculate new capacity. We keep the free capacity at the side that does not have to grow
      .                   // to avoid quadratic behavior with mixed append/prepend cases
      .           
      .                   // use qMax below, because constAllocatedCapacity() can be 0 when using fromRawData()
  2,870 ( 0.00%)          qsizetype minimalCapacity = qMax(from.size, from.constAllocatedCapacity()) + n;
    165 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::constAllocatedCapacity() const (8x)
    104 ( 0.00%)  => /usr/include/qt6/QtCore/qminmax.h:long long const& qMax<long long>(long long const&, long long const&) (8x)
      .                   // subtract the free space at the side we want to allocate. This ensures that the total size requested is
      .                   // the existing allocation at the other side + size + n.
  1,435 ( 0.00%)          minimalCapacity -= (position == QArrayData::GrowsAtEnd) ? from.freeSpaceAtEnd() : from.freeSpaceAtBegin();
    575 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::freeSpaceAtEnd() const (8x)
  1,230 ( 0.00%)          qsizetype capacity = from.detachCapacity(minimalCapacity);
    796 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::detachCapacity(long long) const (8x)
  1,230 ( 0.00%)          const bool grows = capacity > from.constAllocatedCapacity();
    165 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::constAllocatedCapacity() const (8x)
  3,690 ( 0.00%)          auto [header, dataPtr] = Data::allocate(capacity, grows ? QArrayData::Grow : QArrayData::KeepSize);
  6,342 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydata.h:QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::allocate(long long, QArrayData::AllocationOption) (8x)
    160 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_pair.h:std::tuple_element<1ul, std::pair<QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*> >::type&& std::get<1ul, QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*>(std::pair<QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*>&&) (8x)
    152 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_pair.h:std::tuple_element<0ul, std::pair<QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*> >::type&& std::get<0ul, QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*>(std::pair<QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*>&&) (8x)
  2,255 ( 0.00%)          const bool valid = header != nullptr && dataPtr != nullptr;
    820 ( 0.00%)          if (!valid)
      .                       return QArrayDataPointer(header, dataPtr);
      .           
      .                   // Idea: * when growing backwards, adjust pointer to prepare free space at the beginning
      .                   //       * when growing forward, adjust by the previous data pointer offset
  1,262 ( 0.00%)          dataPtr += (position == QArrayData::GrowsAtBeginning)
    410 ( 0.00%)                  ? n + qMax(0, (header->alloc - from.size - n) / 2)
    615 ( 0.00%)                  : from.freeSpaceAtBegin();
    343 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::freeSpaceAtBegin() const (8x)
  1,230 ( 0.00%)          header->flags = from.flags();
    211 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::flags() const (8x)
  1,640 ( 0.00%)          return QArrayDataPointer(header, dataPtr);
    144 ( 0.00%)  => /usr/include/qt6/QtCore/qarraydatapointer.h:QArrayDataPointer<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::QArrayDataPointer(QTypedArrayData<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >*, std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >*, long long) (8x)
  1,435 ( 0.00%)      }
      .           
      .               friend bool operator==(const QArrayDataPointer &lhs, const QArrayDataPointer &rhs) noexcept
      .               {
      .                   return lhs.data() == rhs.data() && lhs.size == rhs.size;
      .               }
      .           
      .               friend bool operator!=(const QArrayDataPointer &lhs, const QArrayDataPointer &rhs) noexcept
      .               {
-- line 512 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qatomic_cxx11.h
--------------------------------------------------------------------------------
Ir               

-- line 192 ----------------------------------------
      .           
      .               template <typename T> static inline
      .               T load(const volatile std::atomic<T> &_q_value) noexcept
      .               {
      .                   return _q_value.load(std::memory_order_relaxed);
      .               }
      .           
      .               template <typename T> static inline
180,992 ( 0.08%)      T loadRelaxed(const std::atomic<T> &_q_value) noexcept
      .               {
136,138 ( 0.06%)          return _q_value.load(std::memory_order_relaxed);
 14,184 ( 0.01%)  => /usr/include/c++/15.1.1/atomic:std::atomic<QMutexPrivate*>::load(std::memory_order) const (394x)
 90,496 ( 0.04%)      }
      .           
      .               template <typename T> static inline
      .               T loadRelaxed(const volatile std::atomic<T> &_q_value) noexcept
      .               {
      .                   return _q_value.load(std::memory_order_relaxed);
      .               }
      .           
      .               template <typename T> static inline
-- line 211 ----------------------------------------
-- line 255 ----------------------------------------
      .                    * back to T, because it's susceptible to integer promotion. To sidestep
      .                    * this issue and to avoid UB on signed overflow, we rewrite the
      .                    * expression to:
      .                    */
      .                   return _q_value.fetch_add(1, std::memory_order_acq_rel) != T(-1);
      .               }
      .           
      .               template <typename T>
119,115 ( 0.06%)      static inline bool deref(std::atomic<T> &_q_value) noexcept
      .               {
      .                   // compare with ref
238,230 ( 0.11%)          return _q_value.fetch_sub(1, std::memory_order_acq_rel) != T(1);
 79,410 ( 0.04%)      }
      .           
      .               static inline bool isTestAndSetNative() noexcept
      .               { return QAtomicTraits<sizeof(X)>::isLockFree(); }
      .               static inline constexpr bool isTestAndSetWaitFree() noexcept { return false; }
      .           
      .               template <typename T>
      .               static bool testAndSetRelaxed(std::atomic<T> &_q_value, T expectedValue, T newValue, T *currentValue = nullptr) noexcept
      .               {
      .                   bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_relaxed, std::memory_order_relaxed);
      .                   if (currentValue)
      .                       *currentValue = expectedValue;
      .                   return tmp;
      .               }
      .           
      .               template <typename T>
  1,379 ( 0.00%)      static bool testAndSetAcquire(std::atomic<T> &_q_value, T expectedValue, T newValue, T *currentValue = nullptr) noexcept
      .               {
  1,576 ( 0.00%)          bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_acquire, std::memory_order_acquire);
 14,775 ( 0.01%)  => /usr/include/c++/15.1.1/atomic:std::atomic<QMutexPrivate*>::compare_exchange_strong(QMutexPrivate*&, QMutexPrivate*, std::memory_order, std::memory_order) (197x)
    394 ( 0.00%)          if (currentValue)
      .                       *currentValue = expectedValue;
    197 ( 0.00%)          return tmp;
    394 ( 0.00%)      }
      .           
      .               template <typename T>
  1,379 ( 0.00%)      static bool testAndSetRelease(std::atomic<T> &_q_value, T expectedValue, T newValue, T *currentValue = nullptr) noexcept
      .               {
  1,576 ( 0.00%)          bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_release, std::memory_order_relaxed);
 14,775 ( 0.01%)  => /usr/include/c++/15.1.1/atomic:std::atomic<QMutexPrivate*>::compare_exchange_strong(QMutexPrivate*&, QMutexPrivate*, std::memory_order, std::memory_order) (197x)
    394 ( 0.00%)          if (currentValue)
      .                       *currentValue = expectedValue;
    197 ( 0.00%)          return tmp;
    394 ( 0.00%)      }
      .           
      .               template <typename T>
      .               static bool testAndSetOrdered(std::atomic<T> &_q_value, T expectedValue, T newValue, T *currentValue = nullptr) noexcept
      .               {
      .                   bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_acq_rel, std::memory_order_acquire);
      .                   if (currentValue)
      .                       *currentValue = expectedValue;
      .                   return tmp;
-- line 306 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/qt6/QtCore/qjsonvalue.h
--------------------------------------------------------------------------------
Ir               

-- line 156 ----------------------------------------
      .               bool isUndefined() const { return type() == QJsonValue::Undefined; }
      .           
      .               bool toBool(bool defaultValue = false) const
      .               { return concreteBool(*this, defaultValue); }
      .               int toInt(int defaultValue = 0) const
      .               { return int(concreteInt(*this, defaultValue, true)); }
      .               qint64 toInteger(qint64 defaultValue = 0) const
      .               { return concreteInt(*this, defaultValue, false); }
176,820 ( 0.08%)      double toDouble(double defaultValue = 0) const
389,008 ( 0.18%)      { return concreteDouble(*this, defaultValue); }
531,564 ( 0.25%)  => ???:QJsonValueConstRef::concreteDouble(QJsonValueConstRef, double) (35,363x)
  1,153 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
      .               QString toString(const QString &defaultValue = {}) const
      .               { return concreteString(*this, defaultValue); }
      .               Q_CORE_EXPORT QJsonArray toArray() const;
      .               Q_CORE_EXPORT QJsonObject toObject() const;
      .           
      .               const QJsonValue operator[](QStringView key) const { return concrete(*this)[key]; }
      .               const QJsonValue operator[](QLatin1StringView key) const { return concrete(*this)[key]; }
      .               const QJsonValue operator[](qsizetype i) const { return concrete(*this)[i]; }
-- line 173 ----------------------------------------
-- line 197 ----------------------------------------
      .               Q_CORE_EXPORT static QString concreteString(QJsonValueConstRef self, const QString &defaultValue);
      .               Q_CORE_EXPORT static QJsonValue concrete(QJsonValueConstRef self) noexcept;
      .           
      .               // for iterators
      .               Q_CORE_EXPORT static QString objectKey(QJsonValueConstRef self);
      .               QString objectKey() const { return objectKey(*this); }
      .           
      .           #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0) && !defined(QT_BOOTSTRAPPED)
 19,700 ( 0.01%)      QJsonValueConstRef(QJsonArray *array, qsizetype idx)
 74,860 ( 0.03%)          : a(array), is_object(false), index(static_cast<quint64>(idx)) {}
      .               QJsonValueConstRef(QJsonObject *object, qsizetype idx)
      .                   : o(object), is_object(true), index(static_cast<quint64>(idx)) {}
      .           
      .               void rebind(QJsonValueConstRef other)
      .               {
      .                   Q_ASSERT(is_object == other.is_object);
      .                   if (is_object)
      .                       o = other.o;
-- line 214 ----------------------------------------
-- line 257 ----------------------------------------
      .               QJsonValueRef(const QJsonValueRef &) = default;
      .               QT7_ONLY(Q_CORE_EXPORT) QJsonValueRef &operator = (const QJsonValue &val);
      .               QT7_ONLY(Q_CORE_EXPORT) QJsonValueRef &operator = (const QJsonValueRef &val);
      .           
      .           #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0) && !defined(QT_BOOTSTRAPPED)
      .               // retained for binary compatibility (due to the Q_CORE_EXPORT) because at
      .               // least one compiler emits and exports all inlines in an exported class
      .           
 23,640 ( 0.01%)      QJsonValueRef(QJsonArray *array, qsizetype idx)
 35,460 ( 0.02%)          : QJsonValueConstRef(array, idx) {}
 94,560 ( 0.04%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueConstRef::QJsonValueConstRef(QJsonArray*, long long) (3,940x)
      .               QJsonValueRef(QJsonObject *object, qsizetype idx)
      .                   : QJsonValueConstRef(object, idx) {}
      .           
298,804 ( 0.14%)      operator QJsonValue() const { return toValue(); }
1,113,300 ( 0.52%)  => ???:QJsonValueRef::toValue() const (14,939x)
  1,169 ( 0.00%)  => ???:0x0000000000012dc0'2 (1x)
      .           
      .               QVariant toVariant() const;
      .               inline QJsonValue::Type type() const { return QJsonValueConstRef::type(); }
      .               inline bool isNull() const { return type() == QJsonValue::Null; }
      .               inline bool isBool() const { return type() == QJsonValue::Bool; }
      .               inline bool isDouble() const { return type() == QJsonValue::Double; }
      .               inline bool isString() const { return type() == QJsonValue::String; }
      .               inline bool isArray() const { return type() == QJsonValue::Array; }
      .               inline bool isObject() const { return type() == QJsonValue::Object; }
      .               inline bool isUndefined() const { return type() == QJsonValue::Undefined; }
      .           
      .               inline bool toBool(bool defaultValue = false) const { return QJsonValueConstRef::toBool(defaultValue); }
      .               inline int toInt(int defaultValue = 0) const { return QJsonValueConstRef::toInt(defaultValue); }
      .               inline qint64 toInteger(qint64 defaultValue = 0) const { return QJsonValueConstRef::toInteger(defaultValue); }
424,368 ( 0.20%)      inline double toDouble(double defaultValue = 0) const { return QJsonValueConstRef::toDouble(defaultValue); }
1,098,545 ( 0.51%)  => /usr/include/qt6/QtCore/qjsonvalue.h:QJsonValueConstRef::toDouble(double) const (35,364x)
      .               inline QString toString(const QString &defaultValue = {}) const { return QJsonValueConstRef::toString(defaultValue); }
      .               QJsonArray toArray() const;
      .               QJsonObject toObject() const;
      .           
      .               const QJsonValue operator[](QStringView key) const { return QJsonValueConstRef::operator[](key); }
      .               const QJsonValue operator[](QLatin1StringView key) const { return QJsonValueConstRef::operator[](key); }
      .               const QJsonValue operator[](qsizetype i) const { return QJsonValueConstRef::operator[](i); }
      .           
-- line 293 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: ../../fuse.cpp
--------------------------------------------------------------------------------
Ir             

    .           #include "fuse.h"
    .           
   11 ( 0.00%)  Fuse::Fuse(QObject *parent)
   18 ( 0.00%)      : QObject{parent}
  326 ( 0.00%)  => ???:QObject::QObject(QObject*) (1x)
   48 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::vector() (1x)
   32 ( 0.00%)  => /usr/include/qt6/QtCore/qqueue.h:QQueue<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::QQueue() (1x)
    .           {
   13 ( 0.00%)      mu = new QMutex();
  202 ( 0.00%)  => /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (1x)
   57 ( 0.00%)  => /usr/include/qt6/QtCore/qmutex.h:QMutex::QMutex() (1x)
   13 ( 0.00%)      m_fusion = new Fusion();
   58 ( 0.00%)  => /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_op.cc:operator new(unsigned long) (1x)
  153 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/fusion.cpp:Fusion::Fusion() (1x)
    6 ( 0.00%)      float camera_position[3] = {5.0f, 10.0f, -10.0f};
    6 ( 0.00%)      float camera_rotation[3] = {0.0f, 0.0f, 0.0f};
    6 ( 0.00%)      PixelToWorld::CameraPose pose(camera_position, camera_rotation);
2,323 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/pixel2world.cpp:PixelToWorld::CameraPose::CameraPose(float*, float*) (1x)
    6 ( 0.00%)      m_fusion->setCameraPose(pose);
   48 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/fusion.cpp:Fusion::setCameraPose(PixelToWorld::CameraPose const&) (1x)
    5 ( 0.00%)      m_radars.resize(6);
1,106 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::resize(unsigned long) (1x)
   22 ( 0.00%)      for (int i = 0; i < 6; ++i) {
  174 ( 0.00%)          m_radars[i] = Fusion::RadarData((-2.5 + i) * RADARS_DISTANCE, 0, 0, -1);
  222 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) (6x)
  132 ( 0.00%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../../UTFusion/./FusionUtils/fusion.h:Fusion::RadarData::RadarData(float, float, float, float) (6x)
    .               }
    .           
   10 ( 0.00%)  }
    .           
    .           void Fuse::unsafeSetRadars(Buffer::RadarData r)
  788 ( 0.00%)  {
2,167 ( 0.00%)      m_radars[0].output_distance = r.a;
7,289 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) (197x)
2,167 ( 0.00%)      m_radars[1].output_distance = r.b;
7,289 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) (197x)
2,167 ( 0.00%)      m_radars[2].output_distance = r.c;
7,289 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) (197x)
2,167 ( 0.00%)      m_radars[3].output_distance = r.d;
7,289 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) (197x)
2,167 ( 0.00%)      m_radars[4].output_distance = r.e;
7,289 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) (197x)
2,167 ( 0.00%)      m_radars[5].output_distance = r.f;
7,289 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> >::operator[](unsigned long) (197x)
  591 ( 0.00%)  }
    .           
    .           void Fuse::dataRecieve(const std::vector<std::vector<Fusion::PixelData> > &values,
    .                                  Buffer::RadarData r)
1,773 ( 0.00%)  {
  788 ( 0.00%)      mu->lock();
44,916 ( 0.02%)  => /usr/include/qt6/QtCore/qmutex.h:QBasicMutex::lock() (197x)
    .               // TODO Hashem
2,758 ( 0.00%)      unsafeSetRadars(r);
58,115 ( 0.03%)  => ../../fuse.cpp:Fuse::unsafeSetRadars(Buffer::RadarData) (197x)
1,379 ( 0.00%)      m_fusion->setRadars(m_radars);
448,801 ( 0.21%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/fusion.cpp:Fusion::setRadars(std::vector<Fusion::RadarData, std::allocator<Fusion::RadarData> > const&) (197x)
  591 ( 0.00%)      std::vector<Fusion::FusionOutput> result;
9,456 ( 0.00%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::vector() (197x)
2,955 ( 0.00%)      result = m_fusion->performFusion(values);
17,395,620 ( 8.13%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/../../FusionUtils/fusion.cpp:Fusion::performFusion(std::vector<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> >, std::allocator<std::vector<Fusion::PixelData, std::allocator<Fusion::PixelData> > > > const&) (197x)
92,393 ( 0.04%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::operator=(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >&&) (197x)
18,321 ( 0.01%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::~vector() (197x)
  788 ( 0.00%)      mu->unlock();
43,931 ( 0.02%)  => /usr/include/qt6/QtCore/qmutex.h:QBasicMutex::unlock() (197x)
1,182 ( 0.00%)      m_queue.enqueue(result);
307,947 ( 0.14%)  => /usr/include/qt6/QtCore/qqueue.h:QQueue<std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > >::enqueue(std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> > const&) (197x)
  591 ( 0.00%)      emit OperationDone();
17,927 ( 0.01%)  => /home/arian/Documents/UTFusion/UTFusion/build/Desktop-Debug/moc_fuse.cpp:Fuse::OperationDone() (197x)
1,773 ( 0.00%)  }
36,642 ( 0.02%)  => /usr/include/c++/15.1.1/bits/stl_vector.h:std::vector<Fusion::FusionOutput, std::allocator<Fusion::FusionOutput> >::~vector() (197x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/15.1.1/bits/move.h
--------------------------------------------------------------------------------
Ir              

-- line 45 ----------------------------------------
     .             /**
     .              *  @brief Same as C++11 std::addressof
     .              *  @ingroup utilities
     .              */
     .             template<typename _Tp>
     .               __attribute__((__always_inline__))
     .               inline _GLIBCXX_CONSTEXPR _Tp*
     .               __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
 3,682 ( 0.00%)      { return __builtin_addressof(__r); }
     .           
     .           #if __cplusplus >= 201103L
     .           
     .             /**
     .              *  @addtogroup utilities
     .              *  @{
     .              */
     .           
-- line 61 ----------------------------------------
-- line 65 ----------------------------------------
     .              *
     .              *  This function is used to implement "perfect forwarding".
     .              *  @since C++11
     .              */
     .             template<typename _Tp>
     .               [[__nodiscard__,__gnu__::__always_inline__]]
     .               constexpr _Tp&&
     .               forward(typename std::remove_reference<_Tp>::type& __t) noexcept
99,113 ( 0.05%)      { return static_cast<_Tp&&>(__t); }
     .           
     .             /**
     .              *  @brief  Forward an rvalue.
     .              *  @return The parameter cast to the specified type.
     .              *
     .              *  This function is used to implement "perfect forwarding".
     .              *  @since C++11
     .              */
-- line 81 ----------------------------------------
-- line 131 ----------------------------------------
     .              *  @param  __t  A thing of arbitrary type.
     .              *  @return The parameter cast to an rvalue-reference to allow moving it.
     .              *  @since C++11
     .             */
     .             template<typename _Tp>
     .               [[__nodiscard__,__gnu__::__always_inline__]]
     .               constexpr typename std::remove_reference<_Tp>::type&&
     .               move(_Tp&& __t) noexcept
 7,986 ( 0.00%)      { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
     .           
     .           
     .             template<typename _Tp>
     .               struct __move_if_noexcept_cond
     .               : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
     .                               is_copy_constructible<_Tp>>::type { };
     .           
     .             /**
-- line 147 ----------------------------------------
-- line 169 ----------------------------------------
     .              *  @param  __r  Reference to an object or function.
     .              *  @return   The actual address.
     .              *  @since C++11
     .             */
     .             template<typename _Tp>
     .               [[__nodiscard__,__gnu__::__always_inline__]]
     .               inline _GLIBCXX17_CONSTEXPR _Tp*
     .               addressof(_Tp& __r) noexcept
   394 ( 0.00%)      { return std::__addressof(__r); }
     .           
     .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
     .             // 2598. addressof works on temporaries
     .             template<typename _Tp>
     .               const _Tp* addressof(const _Tp&&) = delete;
     .           
     .             // C++11 version of std::exchange for internal use.
     .             template <typename _Tp, typename _Up = _Tp>
-- line 185 ----------------------------------------
-- line 219 ----------------------------------------
     .               inline
     .           #if __cplusplus >= 201103L
     .               typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
     .           			      is_move_constructible<_Tp>,
     .           			      is_move_assignable<_Tp>>::value>::type
     .           #else
     .               void
     .           #endif
 2,050 ( 0.00%)      swap(_Tp& __a, _Tp& __b)
     .               _GLIBCXX_NOEXCEPT_IF(__and_<is_nothrow_move_constructible<_Tp>,
     .           				is_nothrow_move_assignable<_Tp>>::value)
     .               {
     .           #if __cplusplus < 201103L
     .                 // concept requirements
     .                 __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
     .           #endif
   820 ( 0.00%)        _Tp __tmp = _GLIBCXX_MOVE(__a);
   615 ( 0.00%)        __a = _GLIBCXX_MOVE(__b);
   615 ( 0.00%)        __b = _GLIBCXX_MOVE(__tmp);
 1,230 ( 0.00%)      }
     .           
     .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
     .             // DR 809. std::swap should be overloaded for array types.
     .             /// Swap the contents of two arrays.
     .             template<typename _Tp, size_t _Nm>
     .               _GLIBCXX20_CONSTEXPR
     .               inline
     .           #if __cplusplus >= 201103L
-- line 246 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  /usr/src/debug/double-conversion/double-conversion/double-conversion/string-to-double.cc
  /usr/src/debug/double-conversion/double-conversion/double-conversion/strtod.cc
  /usr/src/debug/double-conversion/double-conversion/double-conversion/strtod.h
  /usr/src/debug/double-conversion/double-conversion/double-conversion/utils.h
  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/del_op.cc
  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/del_ops.cc
  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/dyncast.cc
  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_op.cc
  /usr/src/debug/gcc/gcc/libstdc++-v3/libsupc++/new_opnt.cc

--------------------------------------------------------------------------------
Ir                  
--------------------------------------------------------------------------------
38,741,660 (18.10%)  events annotated

